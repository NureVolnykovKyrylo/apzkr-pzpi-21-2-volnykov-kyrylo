Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю акваріумів

Студент гр. ПЗПІ-21-2	__________________ Вольников К.С.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Вольникову Кирилу Сергійовичу
1.	Тема роботи: «Програмна система для контролю акваріумів»	
2.	Термін узгодження завдання курсової роботи «_5_»___березня_______ 2024 р.
3.	Термін здачі студентом закінченої роботи «___»___________ 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
можливість монетизації, оригінальність, актуальність, масовість, маштабованість, пітримка інтернаціоналізації, локалізації, забезпечення захисту даних та адміністрування системи, серверна частина проекту (backend), веб платформа (frontend), мобільний додаток, IоT девайс	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки	





КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	10 квітня 2024 року	виконано
2	Проектування програмного
проекту	20 квітня 2024 року	виконано
3	Кодування програмного проекту	28 травня 2024 року	виконано
4	Оформлення пояснювальної
записки	4 червня 2024 року	виконано
5	Захист курсової роботи	10 червня 2024 року	виконано

Дата видачі завдання «___5___»______березня________2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	_________________             Вольников К.С.
(підпис)










РЕФЕРАТ


Пояснювальна записка до курсової роботи: 136 с., 17 рис., 3 додатки, 6 джерел.
АКВАРІУМИ, АРХІТЕКТУРА ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ, МЕШКАНЦІ АКВАРІУМІВ, АНАЛІТИЧНІ ЗВІТИ, КОРИСТУВАЧ, МОБІЛЬНИЙ ЗАСТОСУНОК.
Метою роботи є розробка програмної системи для контролю акваріумів.
Методи розроблення базуються на застосовуванні редактору коду Visual Studio Code та Visual Studio, PostgreSQL, мови програмування JavaScript, С#, ASP.NET Core Web API, ORM Entity Framework, бібліотеки React.JS, мови програмування Kotlin, UI фреймворку Jetpack Compose, мікроконтролеру ESP32, C++.
У результаті отримано програмну систему із назвою «Aqua Track», яка дає користувачам змогу  за допомогою веб-інтерфейсу у ролі адміністратора маніпулювати звичайними користувачами, маніпулювати акваріумами для кожного з користувачів, у ролі користувача переглядати контролюємі акваріуми, маніпулювати мешканцями кожного з акваріумів, маніпулювати звітами досліджень та на основі них створювати і переглядати аналітичні звіти. Мобільний застосунок дозволяє користувачу налаштовувати графіки годування для кожного з його контролюємих акваріумів та реєструвати датчики до системи. Також програмна система дозволяє підключати датчики кислотності, вологості, освітлення, температури акваріуму, активності та стану мешканців. Після фіксації дані вище наведені передаються на сервер, де вони зберігаються  в базі даних для подальшого аналізу.
Така програмна система дозволить автоматизувати контроль за акваріумами, що дозволить як любителям так і професіоналам у галузі акваріумістики забезпечити своєчасне реагування на зміни, моніторинг акваріумів а також зручно отримувати аналітичний звіт по обраному акваріуму.
ЗМІСТ


Вступ	 8
1 Аналіз предметної області	 9
1.1 Бізнес вимоги	 9
1.1.1 Можливості для бізнесу	 9
1.1.2 Цілі бізнесу та критерії успіху	 10
1.1.3 Потреби клієнта або ринку	 10
1.1.4 Бізнес-ризики	 11
1.2 Концепція рішення	 12
1.2.1 Окреслення концепції	 12
1.2.2 Основні особливості	 12
1.2.3 Припущення та залежності	 13
1.3 Рамки та обмеження	 14
1.3.1 Початковий випуск	 14
1.3.2 Сфера дії наступних випусків	 14
1.3.3 Обмеження та виключення	 15
1.4 Бізнес-контекст	 15
1.4.1 Профілі зацікавлених сторін	 15
1.4.2 Пріоритети проєкту	 17
1.4.3 Операційне середовище	 18
2 Проектування програмного проекту	 19
2.1 Аналіз предметної області	 19
2.2 Аналіз інформаційних потреб користувачів	 19
2.3 Проектування бази даних	 21
2.3.1 Проектування бази даних з використанням ER діаграми	 21
2.4 Проектування серверної частини програмної системи 	 22
2.4.1 Архітектура системи	 22
2.4.2 REST специфікація	 22
2.4.3 Розробка сервера	 25
2.4.3.1 База даних та підключення	 25
2.4.3.2 Структура серверу	 26
2.4.3.3 Автентифікація	 26
2.4.3.4 Управління датчиками	 26
2.4.3.5 Управління акваріумами	 27
2.4.3.6 Взаємодія з меншканцями годування	 27
2.4.3.7 Взаємодія з розкладами годування	 28
2.4.3.8 Звіти досліджень	 28
2.4.3.9 Управління аналітичними звітностями	 28
2.5 Проектування програмного забезпечення для IoT пристрою	 29
2.5.1 Моделювання програмного забезпечення для ІоТ пристрою	 29
2.5.2 Взаємодія між частинами системи та ІоТ пристроєм	 30
2.5.3 Архітектура програмного забезпечення для ІоТ пристрою	 31
2.5.4 Програмна розробка системи	 31
2.6 Проектування клієнтської веб-частини програмної системи 	 33
2.6.1 Моделювання клієнтської веб-частини програмної системи 	 33
2.6.2 Архітектура клієнтської веб-частини програмної системи 	 35
2.6.3 Програмна розробка клієнтської веб-частини програмної системи 	 35
2.6.3.1 Компонент AdminAquarium	 36
2.6.3.2 Компонент UserAquarium	 36
2.6.3.3 Компонент Inhabitant	 37
2.6.3.4 Компонент ResearchReport	 37
2.6.3.5 Компонент AnalysisReport	 38
2.7 Проектування клієнтської мобільної частини програмної системи	 38
2.7.1 Моделювання клієнтської мобільної частини програмної системи	 38
2.7.2 Архітектура клієнтської мобільної частини програмної системи	 40
2.7.3 Розробка клієнтської мобільної частини програмної системи	 40
2.7.3.1 Сервіс AquariumApi 	 41
2.7.3.2 Сервіс UserApi 	 41
2.7.3.3 Сервіс FeedingScheduleApi 	 42
2.7.3.4 Сервіс SensorDataApi 	 42
Висновки	 43
Перелік джерел	 44
Додаток А Діаграми	 45
Додаток Б Код програми	 62
Додаток В Результат перевірки пояснювальної записки на плагіат	 136


ВСТУП


Сучасний світ висуває нові вимоги до контролю та автоматизації процесів у різних сферах діяльності, в тому числі і в галузі акваріумістики. Хобісти та професіонали стикаються з необхідністю ретельного моніторингу параметрів водного середовища, годування для забезпечення оптимальних умов існування мешканців акваріумів. Однак традиційні методи ручного контролю є трудомісткими, схильними до помилок і не завжди забезпечують своєчасне реагування на зміни.
Таким чином, передумовами створення програмної системи з догляду за акваріумами є потреба в автоматизації та спрощенні процесів моніторингу та керування, забезпеченні своєчасного реагування на зміни, а також бажання отримати зручний та ефективний інструмент як для любителів, так і для професіоналів у галузі акваріумістики.
 
1 АНАЛІЗ ПРЕДМЕНТНОЇ ОБЛАСТІ
	1.1 Бізнес-вимоги
	1.1.1 Можливості для бізнесу


Аналоги на ринку:
-	Neptune Apex: Cистема, що пропонує спектр функцій, включаючи контроль освітлення, температури, pH та автоматичне дозування.
-	EcoTech Marine ReefLink: Система, що фокусується на управлінні акваріумами з коралами, пропонуючи контроль освітлення, циркуляції та параметрів води.
-	Hydra Smart ATO: Система автоматичного доповнення води, що підтримує постійний рівень води в акваріумі.
Переваги системи в порівнянні із наведеними вище аналогами на ринку полягають в тому, система пропонує комплексний підхід до догляду за акваріумом включаючи налаштування циклів годування, аналітику споживання ресурсів і тому подібне, що робить її незамінним інструментом як для початківців, так і для професійних акваріумістів. 
Модель монетизації:
AquaTrack може запропонувати підписочну модель для доступу до преміального функціоналу догляду за акваріумами та аналітичних інструментів. Співпраця з неприбутковими організаціями може включати спеціальні умови та знижки для них.
Ринок:
«AquaTrack» призначений для промислового ринку, тобто бізнесів, для різних користувачів у будь-яких галузях бізнесу.
Перспективність:
Акваріумісти шукають способи автоматизувати завдання та спростити догляд за акваріумом, що робить систему актуальною та затребуваною.

1.1.2 Цілі бізнесу та критерії успіху


BO-1: Забезпечити доступність додатка для користувачів у різних країнах, надаючи локалізовані версії програми.
BO-2: Забезпечити користувачам інтуїтивний та ефективний досвід користування додатком для контролю за акваріумами.
BO-3: Забезпечення позиціонування «AquaTrack» як лідера на ринку в галузі систем контролю за акваріумами.
BO-4: Запустити систему на ринок з прибутковою моделлю монетизації, а саме підписочною моделлю.
SC-1: Охоплення додатком щонайменше 3-х нових країн з локалізацією протягом першого року.
SC-2: Досягти 15,000 активних користувачів за перші 6 місяців після запуску.
SC-3: Досягти результату у 4000 преміум користувачів за перші 6 місяців.


1.1.3 Потреби клієнта або ринку


Власники акваріумів, як любителі, так і професіонали, потребують ефективних інструментів для контролю та керування складними водними екосистемами. Хобісти шукають зручні засоби для полегшення рутинних процесів догляду за акваріумами, таких як моніторинг параметрів води, годування та дозування хімічних речовин. Їм потрібна система, яка допоможе своєчасно виявляти відхилення від оптимальних умов та надавати рекомендації щодо коригувальних дій.
Професійні користувачі, такі як зоомагазини, виставкові центри чи наукові установи, мають потребу в централізованому контролі та керуванні численними акваріумами. Їм необхідні інструменти для автоматизації процесів, аналізу споживання ресурсів та оптимізації витрат. Наукові організації також зацікавлені в отриманні точних даних для дослідження поведінки водних організмів та впливу різних факторів на водне середовище.
Загалом, ринок потребує комплексного технологічного рішення, яке поєднуватиме різноманітні датчики, пристрої Інтернету речей (IoT), аналітику даних та зручні користувацькі інтерфейси у вигляді веб- та мобільних додатків. Така система має бути гнучкою, масштабованою та простою у використанні для задоволення потреб як любителів, так і професіоналів у галузі акваріумістики.


1.1.4 Бізнес-ризики


Головним бізнес-ризиком є те що ринок контролю за акваріумами може стати конкурентним, і інші компанії можуть пропонувати аналогічні рішення. Запровадження продукту на ринок вимагає ефективного маркетингу та стратегій для виокремлення від конкурентів
Ризиком є те що розробка ґрунтується на сучасних технологіях, і зміни у технологічному ландшафті можуть вплинути на функціональність системи. Необхідно бути готовим до апгрейдів і оновлень.
Додатково необхідно зазначити ризик технічних невдач, які можуть вплинути на надійність та ефективність системи, зокрема, недоліки в датчиках, проблеми з передачею даних та можливі програмні помилки.







1.2 Концепція рішення
1.2.1 Окреслення концепції


Даний проєкт ставить за мету створити рішення для контролю стану акваріумів. Головною метою є розробка системи, яка дозволить автоматизувати процес моніторингу та аналізу параметрів водного середовища в акваріумах різних розмірів, від невеликих домашніх до великих комерційних або наукових установок. Концепція полягає у забезпеченні точного відстеження ключових показників, таких як температура, концентрація розчиненого кисню та інших хімічних складників, освітлення, надаючи актуальну інформацію для аналізу та оптимізації умов утримання водних організмів, запобігання проблемам і підтримання здорового акваріумного середовища.


1.2.2 Основні особливості


MF-1: Реєстрація користувача і створення особистого профілю.
MF-2: Синхронізація даних між веб додатком, мобільним додатком та з IOT приладами.
MF-3: Підтримка декількох мов інтерфейсу.
MF-4: Збір аналітичних даних, які допомагають аналізувати та інтерпретувати інформацію про середовище акваріумів.
MF-5: Підтримка підключення до різних типів датчиків та пристроїв, які збирають загальні дані про середовище акваріумів.
MF-6: Можливість отримувати звіт із рекомендаціями щодо наступних дій на основі поточного стану середовища акваріумів.
MF-7: Зберігання зібраних даних для подальшого їх порівняння з актуальними.
MF-8: Система має дозволяти налаштування циклів годування для мешканців акваріумів.
MF-9: Система надсилає сповіщення та повідомлення користувачам при виявленні відхилення стану акваріумів від оптимальних умов.
MF-10: Можливість отримувати аналітику споживання ресурсів на догляд за акваріумом.


1.2.3 Припущення та залежності


Зал-1: Користувачі системи повинні доступ до Інтернету для синхронізації та обміну даними з іншими користувачами та базою.
Зал-2: Мобільний додаток буде доступний для сучасних операційних систем, а саме Android.
Зал-3: Реалізація системи залежатиме від доступності технологій для використання датчиків тощо.
При-1: Припускається, що існують технічні можливості для встановлення датчиків.
При-2: Припускається, що програмна система може взаємодіяти з бажаним типом датчика.
При-3: Користувачі володіють базовими навичками користування смартфонами і іншими сучасними пристроями.







1.3 Рамки та обмеження
1.3.1 Початковий випуск


У першому випуску програми передбачено наступний функціонал (однаковий для мобільної версії та веб-сайту):
-	Реєстрація користувача та створення особистого профілю з використанням електронної пошти.
-	Синхронізація даних між веб додатком та мобільним додатком.
-	Можливість підключати та використовувати основні типи датчиків для збору загальних даних про середовище акваріумів.
-	Підтримка локалізації інтерфейсу – англійської та української.
-	Додавання функції формування звітів із рекомендаціями щодо наступних дій на основі поточного стану середовища акваріумів.
-	За допомогою пристрою ІоТ будуть також доступні:
-	Збір та збереження даних, які допомагають аналізувати та інтерпретувати інформацію про середовище акваріумів.
-	Можливість налаштування циклів годування для мешканців акваріумів.


1.3.2 Сфера дії наступних випусків


У наступних випусках планується впровадження додатковий функцій:
-	Можливість отримувати аналітику споживання ресурсів на догляд за акваріумом.
-	Отримання сповіщень про відхилення стану акваріумів від зазначених оптимальних умов.

1.3.3 Обмеження та виключення


-	Перший реліз проекту має відбутися у червні 2024 року.
-	Тільки зареєстровані користувачі матимуть змогу користуватись системою.
-	Система повинна забезпечувати конфіденційність даних і захист інформації користувача.
-	Система може заборонити доступ до функції що підпадають під категорію преміальних.
-	Система дозволятиме тільки через адміністраторів видаляти чи редагувати критичну інформацію.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


На таблиці 1 описані профілі зацікавлених сторін:

Таблиця 1 – Профілі зацікавлених сторін
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення до програмного продукту	Основна цінність
Власники акваріумів	Обмеження бюджету для догляду за мешканцями акваріумів та доступ до технічних засобів	Спрощення догляду, забезпечення оптимальних умов для риб, автоматизація рутинних завдань.	Очікують можливість відстежувати основні параметри води, температуру, освітлення та цикли годування	Зменшення зусиль на догляд, покращення здоров'я та добробуту мешканців акваріуму.
Професійні акваріумісти/зоомагазини	Фінансові обмеження та можливість впровадження нових технологій в корпоративні системи	Ефективне управління великою кількістю акваріумів, оптимізація ресурсів, підвищення якості обслуговування клієнтів.	Очікують аналітику споживання ресурсів (вода, корм, електрика) для оптимізації витрат. Очікують можливість генерувати звіти про стан акваріумів для клієнтів.	Підвищення ефективності бізнесу, покращення якості догляду за акваріумами.
Розробник	Ресурси для розробки та технічні вимоги	Розробка якісного продукту	Чекає детальної технічної документації та відгуків користувачів	Реалізація та полірування функціоналу
Наукові та дослідницькі установи	Фінансові та технічні обмеження	Зацікавлені в зборі даних, вивченні екосистем та поведінки мешканців акваріумів	Очікують високу точність та деталізацію даних моніторингу.	Надійні дані для наукових досліджень, спрощення процесів моніторингу та експериментів.



1.4.2 Пріорітети проекту


У процесі створення проекту "AquaTrack" було визначено ключові пріоритети, які відображають головні напрямки та обмеження, на які орієнтуються команда і усі зацікавлені сторони.
Вимоги: Якість виконання та відповідність очікуванням користувачів: продукт повинен відповідати високим стандартам якості та задовольняти очікування користувачів, з основним акцентом на ключових функціональних вимогах, що були визначені у попередніх розділах. 
Графік робіт: Дотримання термінів та пріоритет якості: Виконання проекту в рамках встановленого графіку є важливим, проте якість продукту має пріоритет перед швидкістю виконання робіт. Випуск продукту не може бути відкладений більше ніж на 3 тижні від початково запланованої дати.
Бюджет: Виділений бюджет проекту обмежений, проте допустиме його перевищення може складати до 9% від початкового і тільки в непередбачених випадках та у згоді з керівниками проекту.
Розмір команди: Розмір команди проекту є фіксованим, тому розширення команди під час роботи над проектом не планується. Всі ресурси повинні бути максимально ефективно використані.
Незавершеність проекту: Більшість запланованих для проекту основних особливостей має бути реалізовано до випуску проекту, незавершеність проекту може складати максимум з двох основних особливостей які не мають критичного впливу на роботу системи.






1.4.3	Операційне середовище


а) Програмні платформи:
-	Мобільні платформи: Kotlin
-	IоT платформа: Arduino emulator
-	Веб платформа: React
б) СУБД: PostgreSQL
в) Фреймворки:
-	Backend: ASP.NET Core
-	Frontend: React
г) Мови програмування: C#, JavaScript, Kotlin, C++, HTML, CSS
ґ) Вимоги до системи:
-	Доступність: Система має забезпечувати максимальну доступність для користувачів.
-	Продуктивність: Завантаження системи та відгук на користувацькі дії має бути менше 2 секунд.
-	Конфіденційність: аутентифікація та авторизація за поштою.
-	Сумісність: Система має бути сумісною з використовуваними типами датчиків
 
2 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЕКТУ
2.1 Аналіз предметної області


Для початку роботи необхідно провести концептуальне моделювання предметної області.
З використанням програмної системи користувачі повинні мати можливість зберігати, редагувати, видаляти, отримувати звіти досліджень та їх аналітику за інформацією, що стосується контролю за акваріумами та мешканцями які в них проживають.
Система матиме розподіл за двома ролями користувачів:
-	Звичайний користувач;
-	Адміністратор системи.


2.2 Аналіз інформаційних потреб користувачів


Наступним кроком необхідно проаналізувати інформаційні потреби обох видів користувачів системи.
Для цього було розроблено UML діаграму прецедентів для звичайного користувача та адміністратора (див. А.1).
У програмній системі користувач матиме можливість:
а) Взаємодіяти з особистим акаунтом:
-	Реєструватись у системі
-	Входити/виходити з системи
-	Переглядати/редагувати інформацію профілю
б) Взаємодіяти з аналітичними звітностями:
-	Переглядати створені аналітичні звітності
в) Взаємодіяти з розкладами годування:
-	Переглядати список розкладів годування
-	Додавати нових розкладів
-	Редагувати існуючі розклади
-	Видаляти розклади
г) Взаємодіяти з звітами досліджень:
-	Формувати звіт дослідження на основі інформації з датчиків, та про тварин і середовища в якому вони живуть
-	На основі сформованого звіту формувати аналітичну звітність
ґ) Взаємодія з датчиками:
-	Переглядати список доданих датчиків
-	Додавати новий датчик що буде слугувати для досліджень
-	Видаляти непотрібні датчики
д) Взаємодія з акваріумами:
-	Переглядати список акваріумів
-	Перегляд конкретного акваріуму
-	Перегляд списку мешканців в конкретному акваріумі
-	Додавання мешканців до конкретного акваріуму
-	Редагування інформації яка стосується мешканців в конкретному акваріумі
-	Видалення мешканців з конкретного акваріуму
В той же час адміністратор матиме можливість:
а) Керувати користувачами в системі:
-	Переглядати список користувачів
-	Додавати нових користувачів
-	Редагувати існуючих користувачів
-	Видаляти користувачів

б) Керувати переліком акваріумів для користувачів:
-	Переглядати
-	Додавати нові
-	Редагувати існуючі
-	Видаляти


2.3 Проектування бази даних
2.3.1 Проектування бази даних з використанням ER діаграми


Для проектування структури бази даних програмної системи було розроблено ER діаграму (див. А.3).
База даних міститиме 8 таблиць та 31 неключовий атрибут. Нижче наведено детальний опис усіх зв’язків між таблицями в базі даних.
Один користувач може мати багато акваріумів за якими він доглядає, але один акваріум який адміністратор створює кожному користувачу окремо належить лише одному користувачу. Багато мешканців можуть належати до одного акваріуму, проте у кожного мешканця лише один акваріум в якому він проживає на даний час. Багато розкладів годування (активних та неактивних) можуть належати до одного акваріуму, проте у кожного розкладу може бути лише один акваріум, для якого його назначили. На основі одного звіту дослідження можна сформувати лише один аналіз дослідження, зв’язок 1 до 1. Один звіт з дослідження акваріуму може належати лише одному акваріуму, але один акваріум може мати багато звітів досліджень. Для зв’язку між датчиками і звітом дослідження використовується проміжна таблиця для відношення багато до багатьох.




2.4 Проектування серверної частини програмної системи
2.4.1 Архітектура системи


Для початку роботи було розроблено UML діаграму розгортання (див. А.4). Програмна система міститиме 5 структурних частин:
-	Серверна частина
-	База даних
-	Веб застосунок
-	Мобільний застосунок
-	IoT девайс
З використанням діаграми було визначено зв’язки між вищезазначеними структурними частинами, а також протоколи їх взаємодії між собою.
Також для системи було розроблено UML діаграму станів (див. А.2).


2.4.2 REST специфікація


Аналітична звітність (AnalysisReport)
-	GET /api/AnalysisReport: Отримання списку всіх аналітичних звітностей поточного користувача.
-	POST /api/AnalysisReport: Створення нової аналітичної звітності
-	GET /api/AnalysisReport/{id}: Отримання конкретної аналітичної звітності.
-	PUT /api/AnalysisReport/{id}: Редагування конкретної аналітичної звітності.
-	DELETE /api/AnalysisReport/{id}: Видалення конкретної аналітичної звітності.

Розклад годування (FeedingSchedule)
-	GET /api/FeedingSchedule: Отримання списку всіх розкладів годування поточного користувача.
-	POST /api/FeedingSchedule: Створення нового розкладу годування
-	GET /api/FeedingSchedule/{id}: Отримання конкретного розкладу годування.
-	PUT /api/FeedingSchedule/{id}: Редагування конкретного розкладу годування.
-	DELETE /api/FeedingSchedule/{id}: Видалення конкретного розкладу годування.
Мешканець (Inhabitant)
-	GET /api/Inhabitant/aquarium/{id}: Отримати перелік мешканців в конкретному акваріумі поточного користувача.
-	GET /api/Inhabitant/{id}: Отримати конкретного мешканця.
-	POST /api/Inhabitant: Додати мешканця для поточного користувача до обраного акваріуму.
-	PUT /api/Inhabitant/{id}: Оновити мешканця для поточного користувача із акваріуму.
-	DELETE /api/Inhabitant/{id}: Видалити мешканця для поточного користувача із акваріуму
Акваріум (Aquarium)
-	GET /api/Aquarium/current-user: Отримати перелік акваріумів поточного користувача.
-	GET /api/Aquarium/user/{id}: Отримати перелік акваріумів конкретного користувача.
-	POST /api/Aquarium/user/{id}: Додати новий акваріум конкретному користувачу.
-	PUT /api/Aquarium/{id}/user/{userId}: редагувати конкретний акваріум конкретного користувача.
-	GET /api/Aquarium/{id}: Отримати конкретний акваріум.
-	DELETE /api/Aquarium/{id}: Видалити конкретний акваріум.
Звіт дослідження (ResearchReport)
-	GET /api/ResearchReport: Отримати перелік звітів дослідження поточного користувача.
-	POST /api/ResearchReport: Створити новий звіт дослідження для поточного користувача.
-	GET /api/ResearchReport/{id}: Отримати конкретний звіт дослідження поточного користувача.
-	PUT /api/ResearchReport/{id}: Відредагувати конкретний звіт дослідження поточного користувача.
-	DELETE /api/ResearchReport/{id}: Видалити конкретний звіт дослідження поточного користувача.
Дані датчика (SensorData)
-	GET /api/SensorData: Отримати перелік датчиків які використовує поточний користувач.
-	POST /api/SensorData: Додати новий датчик  для поточного користувача.
-	GET /api/SensorData /{id}: Отримати конкретний датчик поточного користувача.
-	PUT /api/SensorData/{id}: Редагувати конкретний датчик поточного користувача.
-	DELETE /api/SensorData/{id}: Видалити конкретний датчик поточного користувача.
Користувач (User)
-	POST /api/User/login: Автентифікація користувача за допомогою електронної пошти та пароля.
-	POST /api/User/register: Реєстрація нового користувача.
-	GET /api/User/userinfo: Отримати інформацію профілю поточного користувача.
-	PUT /api/User/update: Оновити профіль поточного користувача.
-	POST /api/User/logout: Вихід поточного користувача з системи.
-	GET /api/User/all: Отримати перелік усіх користувачів системи.
-	DELETE /api/User/{userId}: Видалити конкретного користувача із системи.
-	POST /api/User/add: Додати користувача до системи.
-	PUT /api/User/update/{userId}: Відредагувати інформацію про конкретного користувача системи.


2.4.3 Розробка сервера


У якості технології для розробки серверної частини було використано ASP.NET Core Web API та мову програмування C#. У якості середовища розробки було використано Visual Studio.


2.4.3.1 База даних та підключення


Для роботи з базою даних було використано pgAdmin. Для взаємодії з базою даних з серверної частини було використано Entity Framework Core.
Для створення таблиць в базі даних було використано code-first підхід: створено класи в програмі та використано міграції на підключену базу даних.


2.4.3.2 Структура серверу


Точкою входу на сервер є контролери. Після отримання запиту клієнта контролери передають управління сервісам. Сервіси відповідають за бізнес логіку додатку. Варто зазначити, що для взаємодії з базою даних сервіси використовують репозиторії, які вже безпосередньо підтримують зв’язок з базою даних через Entity Framework.


2.4.3.3 Автертифікація


Під час реєстрації новий користувач записується до бази даних (див. Б.3, рядок 96). Пароль користувача хешується та в базі зберігається лише хеш, для забезпечення безпеки.
Для того щоб мати можливість відслідковувати сесію користувача після реєстрації одразу проводиться вхід до системи, під час якого до файлів cookies додається ідентифікатор поточного користувача та його роль (див. Б.3, рядок 105 - 108).
Під час виходу з системи ця інформація очищується з файлів cookies (див. Б.3, рядок 72).


2.4.3.4 Управління датчиками


Користувач має можливість додавати датчики які будуть надсилати інформацію для формування звітів. Сервер від клієнту отримує інформацію про температуру, рівень води, кислотність води, освітленість акваріуму або про стан чи активність мешканця в залежності від типу датчика (див. Б.7, рядок 54). 
Користувач також має можливість переглядати додані датчики (див. Б.7, рядок 22), а також видаляти непотрібні датчики за необхідності (див. Б.7, рядок 67).


2.4.3.5 Управління акваріумами


Адміністратор має можливість додавати нові акваріуми конкретним користувачам до бази даних. Під час цього процесу до бази даних додається новий акваріум, яке може побачити у себе користувач, якому було назначено цей акваріум для контролю (див. Б.2, рядок 78).
Адміністратор також може переглядати список усіх доданих акваріумів для конкретних користувачів (див. Б.2, рядок 60), редагувати інформацію про будь-який акваріум (див. Б.2, рядок 98), або ж зовсім його видалити (див. Б.2, рядок 123). 


2.4.3.6 Взаємодія з мешканцями акваріумів


Користувач має можливість додати нового мешканця в один із своїх акваріумів для подальшого догляду, при цьому обов’язково треба обрати у якому акваріумі живе цей мешканець обравши із вже існуючих варіантів (див. Б.5, рядок 62). 
Також після додавання мешканців, користувач може переглянути усіх мешканців в конкретних акваріумах яких він зараз доглядає (див. Б.5, рядок 31), редагувати будь якого з них, наприклад бажаючи дописати додаткові замітки (див. Б.5, рядок 90), чи зовсім видалити (див. Б.5, рядок 115).

2.4.3.7 Взаємодія з розкладами годування


Користувач має можливість додати новий розклад годування для одного із своїх акваріумів, при цьому обов’язково треба обрати для якого акваріуму назначається цей розклад, обравши із вже існуючих варіантів і чи активний цей розклад (див. Б.4, рядок 62). 
Також після додавання розкладів годування, користувач може переглянути усі розклади для акваріумів (див. Б.4, рядок 29), редагувати будь який з них, наприклад бажаючи поставити той чи інший розклад активним або ні (див. Б.4, рядок 92), чи зовсім видалити (див. Б.4, рядок 122).


2.4.3.8 Звіти досліджень


Користувач може формувати звіти досліджень. Сервер отримує інформацію про акваріуми та їх мешканців, що досліджувалися та відповідну інформацію з датчиків, та все це групується в один запис що відповідає звіту з дослідження даних за останній час. Цей запис додається до бази даних (див. Б.6, рядок 43).


2.4.3.9 Управління аналітичними звітностями


Користувач може формувати аналітичну звітність на основі звіту дослідження. Аналітична звітність отримує зі звіту інформацію про акваріуми та їх мешканців, а також отримує інформацію з дачиків які брали участь у дослідженні, на основі зібраних даних формується опис загальних тенденцій які спостерігаються у порівнянні зі звичайним станом акваріуму та його мешканців, а також формуються рекомендації щодо дій на основі проаналізованих тенденцій (див. Б.1, рядок 82).
Також користувач може переглядати раніше сформовані аналітичні звітності (див. Б.1, рядок 40), та видаляти їх (див. Б.1, рядок 75).


2.5 Проектування програмного забезпечення для IoT пристрою
2.5.1 Моделювання програмного забезпечення для IoT пристрою


Задля розгляду функціональності було побудовано Use-Case діаграму (див. А5), що відображає ролі в системі. Наявні дві ролі: датчик, бо є функціонал який виконує датчик самостійно, а також користувач системи, якій може керувати та адмініструвати IoT пристрій.
Щодо розгляду функціональності датчиків, на Use-Case діаграмі (див.  А5) можемо побачити, що кожен датчик має можливість отримувати показники вологості, температури, кислотності, освітлення акваріуму, активності та стану мешканця акваріуму, та надсилати їх на сервер включно із прорахованим рівнем води для отриманого акваріуму, для отриманого акваріуму також встановлюється розклад годування, функціонал для взаємодії з серверною частиною (функції для GET та POST запитів до сервера).
У користувача системи є можливість управління датчиками та додавання нових датчиків, що будуть збирати данні, а також своєї автентифікації задля управління правильним переліком датчиків, що належить саме цьому користувачу. Це також відображено на Use-Case діаграмі (див. А5), а саме: перегляд списку датчиків з їх актувальними даними, додавання та видалення датчиків.
Повний цикл системи можна описати наступним чином:
-	Користувач при першому використанні системи повинен локально підключитися до контролеру для для створення необхідних датчиків та налаштувань типу цих датчиків та їх ідентифікаторів. 
-	Після успішної реєстрації датчиків в системі, система починає виконувати свій функціонал, спочатку система отримує дані з датчиків, далі система перевіряє чи відповідний користувач намагається оновити дані відповідних зареєстрованих датчиків на сервері, отримує відповідний акваріум з серверу на основі якого прораховує поточний рівень води в акваріумі, назначає розклад годування акваріуму, після чого оновлює дані датчиків на сервері, також вказуючи час отримання оновлених даних для кожного з датчиків.
-	При отриманні даних сервером та їх обробці, сервер інтерпритує дані датчику температури в градусах Цельсія, рівня води у сантиметрах, освітлення в Люксах, кислотності в pH, активності мешканця та стану мешканця у відсотках.
-	Після чого дані зберігаються в базі даних та можуть бути використані сервером для подальшої їх обробки та використанні. Цикл наведених кроків буде повторюватись до поки систему не буде вимкнено від живлення.


2.5.2 Взаємодія між частинами системи та IoT пристроєм


Взаємодія цієї частини з іншими частинами системи відбувається через серверну частину, яка містить необхідні методи для взаємодії, до цих методів належать: метод для автентифікації користувача, щоб підтвердити що сенсор належить саме цьому користувачу, метод для отримання переліку зареєстрованих датчиків користувачем, метод для отримання даних про відповідний акваріум, а також метод для оновлення даних відповідного зареєстрованого датчика, що належить користувачу. 
Як приклад відображення взаємодії було створено діаграму взаємодії на основі діаграми активності щодо обробки даних (див. А7). На цій діаграмі можна докладніше поглянути на послідовність дій власне програми, а також як відбувається взаємодія з серверною частиною. 


2.5.3 Архітектура програмного забезпечення для IoT пристрою


Програмне забезпечення для пристрою IoT було розроблено на мові програмування С++ у симуляторі Wokwi. Для відтворення фізичної системи було використано мікроконтроллер Arduino ESP32, які має можливість підключення до мережі та виходу в Інтернет, що необхідно для взаємодії з серверною частиною, датчик DHT22 для підрахунку вологості та температури, аналогові потенціометри POT для демонстрації можливості відслідковування кислотності акваріуму та показників активності мешканців акваріуму і їх стану, датчик LDR для відслідковування освітлення акваріуму. Також в програмі використовуються HTTP-запити для взаємодії з серверною частиною, бібліотеки HTTpClient для реалізації запитів, NTCClient та TimeLib для роботи з часом, ArduinoJson для обробки відповіді з серверної частини.


2.5.4 Програмна розробка системи


Перед початком написання коду було створено схему для фізичного розміщення частин системи: контроллера та сенсорів (див. А9). Принцип підключення до контролера полягає в наступному: якщо сенсор DHT22 буде використовуватися для виміру і температури, і вологості, то його необхідно підключати до піна ESP23, всі інші підключення цих сенсорів робляться аналогічно, якщо потенціометр POT буде використовуватись для відображення активності мешканців необхідно підключати до піна ESP33, якщо потенціометр POT буде використовуватись для відображення стану мешканців необхідно підключати до піна ESP32, всі інші підключення цих сенсорів робляться аналогічно, якщо потенціометр POT буде використовуватись для відображення кислотності акваріуму необхідно підключати до піна ESP35, якщо датчик LDR  буде використовуватись для виміру освітлення, то його необхідно підключати до піна ESP34 (всі підключення відбуваються з виходу SDA). Інші виходи сенсора потрібно підключати так: VCC до 3V3, GND до GND.
Після створення схеми фізичного розміщення частин починається написання коду. Спочатку оголошуються глобальні константні змінні, що повинні бути доступні в усіх методах програми. Це змінні номерів пінів підключення сенсорів, параметри мережі, частота надсилання спостережень на серверну частину, HTTP та NTP клієнти, адреса серверної частини.
В методі setup() відбувається налаштування системи. Спочатку аналізуються піни та чи підключені до них датчики, після чого починаються спроби підключитися до мережі.
Після підключення та всіх налаштувань системи починається робота з сервером: в методі loop() кожен сенсор надає дані про значення які він спостеріг, також отримується тип цього сенсора та ідентифікатор акваріуму чи мешканця акваріуму за якими він спростерігає. Далі також відбувається автентифікація користувача, щоб визначити, що датчики належать саме цьому користувачу, якщо автертифікація пройшла успішно, то кожен датчик буде намагатись отримати відповідний собі запис в базі даних для цього користувача, також буде отримання відповідного акваріуму, на основі якого буде розраховано поточний рівень води цього акваріуму, а також встановлено розклад годування для цього акваріуму, далі дачики будуть намагатись оновити дані зареєстрованого користувачем датчика на найбільш актувальні (див. Б9). Увесь функціонал методу loop() буде відбуватися до поки контролер не буде вимкнено, та з встановленою частотою.
Код методу updateSensorData() наведено в додатках (див. Б8 рядок 129). Він створює адресу за якою потрібно створити POST запит до сервера, після цього створюється JSON об’єкт з усіма даними датчика для оновлення сервером, після чого відправляється запит на сервер.
Код методу calculateCurrentWaterLevel() наведено в додатках (див Б10). Він на основі нормальних показників акваріуму та значень датчиків розраховує поточний рівень води в цьому акваріумі.
Код методу getAquariumByType() наведено в додатках (див Б8 рядок 85). Він використовується для створення GET запиту до сервера, щоб отримати JSON об’єкт із відповідним акваріумом.
Код методу getFeedingSchedulesForAquarium() наведено в додатках (див Б8 рядок 167). Він використовується для створення GET запиту до сервера, щоб отримати JSON об’єкт із розкладами годування для відповідного акваріуму.


2.6 Проектування клієнтської веб-частини програмної системи
2.6.1 Моделювання клієнтської веб-частини програмної системи


З використанням програмної системи користувачі повинні мати можливість зберігати, редагувати, видаляти, отримувати звіти досліджень та їх аналітику за інформацією, що стосується контролю за акваріумами та мешканцями які в них проживають.
Система матиме розподіл за двома ролями користувачів:
-	Звичайний користувач;
-	Адміністратор системи.
Було розроблено UML діаграму прецедентів для користувача та адміністартора (див. А.10).
У програмній системі користувач матиме можливість:
а) Взаємодіяти з особистим акаунтом:
-	Реєструватись у системі
-	Входити/виходити з системи
б) Взаємодіяти з аналітичними звітностями:
-	Переглядати створені аналітичні звітності
в) Взаємодіяти з звітами досліджень:
-	Формувати звіт дослідження на основі інформації з датчиків, та про мешканців і акваріуми в якому вони живуть
-	На основі сформованого звіту формувати аналітичну звітність
г) Взаємодія з акваріумами:
-	Переглядати список акваріумів
-	Перегляд конкретного акваріуму
-	Перегляд списку мешканців в конкретному акваріумі
-	Додавання мешканців до конкретного акваріуму
-	Редагування інформації щодо мешканців в конкретному акваріумі
-	Видалення мешканців з конкретного акваріуму
В той же час адміністратор матиме можливість:
а) Керувати користувачами в системі:
-	Переглядати список користувачів
-	Редагувати існуючих користувачів
-	Видаляти користувачів
б) Керувати переліком акваріумів для користувачів:
-	Переглядати
-	Додавати нові
-	Редагувати існуючі
-	Видаляти






2.6.2 Архітектура клієнтської веб-частини програмної системи


Для розробки клієнтської частини було використано бібліотеку React, мову програмування Javascript та мови HTML та CSS.
Для дизайну використовується компонентна бібліотека MUI.
Проект має наступну архітектуру:
-	Api services – містять логіку для взаємодії із сервером.
-	Components – відповідають за представлення у системі.
-	Public files – відповідають за зберігання публічно доступних файлів для системи, наприклад файли із локалізацією.
-	Utils – містять допоміжну логіку для системи.
Ця клієнтська частина взаємодіє із серверною частиною реалізованою за допомогою ASP.NET Web Api, завдяки використанню POST, PUT, GET, DELETE HTTP-запитів. Також було створено UML діаграму компонент для демонстрації структури компонентів розробленої системи (див. А.12).


2.6.3 Програмна розробка клієнтської веб-частини програмної системи


Основним функціоналом програмної системи є перегляд інформації про акваріуми та їх мешканців, створення звітів дослідження по цим акваріумам та їх мешканцям, і на основі звітів дослідження створення аналітичних звітів із виявленими тенденціями та рекомендаціями щодо дій.
Було розроблено діаграму станів (див. А.13) та UML діаграму активності (див. А.11) задля можливості демонстрації взаємодії користувача та програмної системи.


2.6.3.1 Компонент AdminAquarium


React-компонент призначений для адміністрування акваріумів користувача. Він використовує React Hooks (`useState`, `useEffect`) для управління станом і побічними ефектами, а також бібліотеку Material-UI для створення інтерфейсу. Ключові моменти: компонент отримує список акваріумів користувача через API-запит (`getAquariumsForUser`) (див. Б.11, рядки 5, 24), відображає їх у вигляді списку з можливістю додавання нового акваріуму, оновлення та видалення існуючих (див Б.11, рядки 61-97). Важливо, що компонент підтримує інтернаціоналізацію з використанням `react-i18next`, а навігація між різними сторінками (додавання, оновлення, перегляд акваріумів) реалізована за допомогою `react-router-dom`. Обробка помилок здійснюється через `try`/`catch`, а візуальне оформлення забезпечується компонентами Material-UI, такими як `Button`, `List`, `Divider.


2.6.3.2 Компонент UserAquarium


React-компонент UserAquarium схожий за структурою з попереднім AdminAquarium, але призначений для звичайних користувачів, а не для адміністраторів. Основні відмінності: компонент отримує ідентифікатор користувача (userId) і використовує його для отримання списку акваріумів користувача через API (див Б.12, рядки 17, 20-30). На відміну від адміністративного інтерфейсу, тут користувач не має можливості додавати, оновлювати або видаляти акваріуми - він може лише переглядати їх деталі та перейти до управління мешканцями кожного акваріуму (див Б.12, рядки 49-78), відсутність кнопок для додавання, оновлення та видалення). Інтерфейс також побудований з використанням Material-UI, з підтримкою інтернаціоналізації через react-i18next. Навігація реалізована за допомогою react-router-dom, дозволяючи перехід до сторінок перегляду акваріуму та управління його мешканцями. Обробка помилок та оновлення стану компонента здійснюються так само, як і в AdminAquarium.


2.6.3.3 Компонент Inhabitant


React-компонент Inhabitant відповідає за відображення та управління списком мешканців певного акваріуму. Він використовує React Hooks (useState, useEffect) для керування станом і життєвим циклом компонента, Material-UI для створення інтерфейсу користувача, react-i18next для інтернаціоналізації тексту та react-router-dom для навігації. Компонент отримує ідентифікатор акваріуму з URL-параметрів, завантажує список його мешканців з API при монтуванні та оновлює цей список при зміні ідентифікатора (див. Б.13, рядки 16-17, 19-30). Він відображає список мешканців у вигляді переліку, де кожен елемент має кнопки для оновлення, видалення та перегляду інформації про мешканця (див. Б.3, рядки 59-96). Також є кнопка для додавання нових мешканців (див. Б.13, рядки 47-55). При натисканні на кнопку видалення, компонент викликає відповідну API-функцію та оновлює локальний стан, видаляючи мешканця зі списку (див. Б.13, рядки 32-40, 77-84).


2.6.3.4 Компонент ResearchReport


Цей React-компонент відповідає за відображення та управління списком звітів дослідження. Він використовує React Hooks для управління станом і ефектами, Material-UI для створення інтерфейсу та react-i18next для інтернаціоналізації. При завантаженні, компонент отримує всі дослідницькі звіти та відповідні типи акваріумів з API, зберігаючи їх у стані (див. Б.14, рядки 21-42). Користувач може фільтрувати звіти за типом акваріуму, використовуючи текстове поле (див. Б.14, рядки 18, 54-58, 75-81). Кожен звіт у списку відображається з його ідентифікатором та типом акваріуму, а також має кнопку для видалення (див. Б.14, рядки 84-104). При натисканні на кнопку видалення, компонент видаляє звіт через API та оновлює локальний стан (див. Б.14, рядки 44-52, 93-102). Також є кнопка для додавання нових звітів, яка веде на іншу сторінку (див. Б.14, рядки 65-73). Компонент ефективно обробляє асинхронні запити, обробляє помилки та забезпечує зручний інтерфейс для роботи з звітами дослідження.


2.6.3.5 Компонент AnalysisReport


Цей React компонент відображає список аналітичних звітів. Він використовує React Router для навігації та Material UI для візуальних елементів. Спочатку компонент отримує всі створені аналітичні звіти, потім для кожного з них знаходить пов'язаний звіт про дослідження та тип акваріума, за яким проводилося дослідження (див. Б.15, рядки 24-52, 26-27, 29-34, 36-45). Користувач може фільтрувати звіти за типом акваріума (див. Б.15, рядки 20, 68-75, 92-98). Також компонент дозволяє додавати нові аналітичні звіти (див. Б.15, рядки 82-90), переглядати існуючі (див. Б.15, рядки 64-66, 124-132) та видаляти їх (див. Б.15, рядки 54-62, 115-123).


2.7 Проектування клієнтської мобільної частини програмної системи
2.7.1 Моделювання клієнтської мобільної частини програмної системи


З використанням програмної системи користувачі повинні мати можливість зберігати, редагувати, видаляти, отримувати інформацію про акваріуми, графіки годування та датчики, які стосуються контролю за акваріумами та мешканцями які в них проживають.
Система матиме розподіл за двома ролями користувачів:
-	Звичайний користувач;
-	Адміністратор системи.
Для цього було розроблено UML діаграму прецедентів для звичайного користувача та адміністратора (див. А.14).
У програмній системі користувач матиме можливість:
а) Взаємодіяти з особистим акаунтом:
-	Реєструватись у системі
-	Входити/виходити з системи
-	Переглядати/редагувати інформацію профілю
б) Взаємодіяти з розкладами годування:
-	Переглядати список розкладів годування
-	Додавати нових розкладів
-	Редагувати існуючі розклади
-	Видаляти розклади
в) Взаємодія з датчиками:
-	Переглядати список доданих датчиків
-	Додавати новий датчик що буде слугувати для досліджень
-	Видаляти непотрібні датчики
г) Взаємодія з акваріумами:
-	Переглядати список акваріумів
В той же час адміністратор матиме можливість:
а) Взаємодіяти з переліком акваріумів для користувачів:
-	Переглядати перелік акваріумів



2.7.2 Архітектура клієнтської мобільної частини програмної системи


Для розробки клієнтської частини було використано бібліотеку Jetpack Compose, мову програмування Kotlin та Android Studio IDE. 
Для дизайну використовується Material Design 3, вбудований у Jetpack Compose.
Проект має наступну архітектуру:
-	Api – містить інтерфейси та імплементації для взаємодії з віддаленим API через HTTP-клієнт Ktor.
-	Models – визначає моделі даних, такі як User та Aquarium та інші.
-	Network – містить конфігурацію HTTP-клієнта та провайдера клієнта.
-	Pages – відповідають за представлення різних екранів додатку, таких як сторінка входу, реєстрації та список акваріумів.
-	Components – містить повторно використовувані компоненти користувацького інтерфейсу, такі як AquariumCard та інші.
-	ViewModels – інкапсулюють стани та логіку додатку, використовуючи архітектурний патерн ViewModel. Наприклад, UserViewModel керує станами користувача та аутентифікацією.
Ця клієнтська частина взаємодіє із серверною частиною реалізованою за допомогою ASP.NET Web Api, завдяки використанню POST, PUT, GET, DELETE HTTP-запитів. Також було створено UML діаграму компонент для демонстрації структури компонентів розробленої системи (див. А.16).


2.7.3 Розробка клієнтської мобільної частини програмної системи


Основним функціоналом за який відповідає ця частина програмної системи є перегляд інформації про акваріуми, керування графіками годування для кожного з акваріумів, керування датчиками які в подальшому будуть використовуватись системою для іншої бізнес логіки. Було розроблено діаграму станів (див. А.17) та UML діаграму активності (див. А.15) задля можливості демонстрації взаємодії користувача та програмної системи.


2.7.3.1 Сервіс AquariumApi


Це сервіс для взаємодії з API, що стосується акваріумів (AquariumApi). Він визначає інтерфейс AquariumApi з двома функціями: getAquariumById для отримання акваріуму за його ідентифікатором та getAquariumsForUser для отримання списку акваріумів користувача за ідентифікатором користувача. Інтерфейс приймає HttpClient, який використовується для виконання HTTP-запитів. Реалізація AquariumApiImpl використовує клієнт Ktor для виконання GET-запитів до віддаленого API, базуючись на заданому apiKey. Якщо запит виконано успішно, повертається відповідний об'єкт або список об'єктів Aquarium. У разі невдачі викидається виняток AquariumApiException з відповідним повідомленням про помилку.


2.7.3.2 Сервіс UserApi


Цей сервіс являє собою реалізацію інтерфейсу UserApi для взаємодії з користувачами в межах додатку AquaTrackMobile. Він надає три основні методи: loginUser, який дозволяє користувачеві авторизуватися за допомогою електронної пошти та пароля; getCurrentUser, який отримує інформацію про поточного користувача; та registerUser, який дозволяє створити новий обліковий запис користувача, надаючи електронну пошту, пароль та ім'я користувача. Ці методи взаємодіють з віддаленим API за допомогою HTTP-клієнта Ktor, відправляючи POST та GET запити з відповідними тілами запитів та отримуючи відповіді у форматі JSON. Також реалізовано обробку винятків LoginException та RegisterException для вирішення проблем, пов'язаних з авторизацією та реєстрацією користувачів..


2.7.3.3 Сервіс FeedingScheduleApi


Сервіс FeedingScheduleApi визначає методи для роботи з розкладами годування у додатку AquaTrackMobile. Він надає можливість отримувати списки розкладів годування за ідентифікатором акваріума, отримувати окремі розклади за ідентифікатором, додавати, оновлювати та видаляти розклади годування для поточного користувача. Ці методи взаємодіють з віддаленим API за допомогою HTTP-клієнта Ktor, відправляючи GET, POST, PUT та DELETE запити та обробляючи відповіді у форматі JSON. Також реалізовано виняток FeedingScheduleApiException для обробки помилок, пов'язаних з цими операціями.


2.7.3.4 Сервіс SensorDataApi


Сервіс SensorDataApi визначає методи для роботи з даними сенсорів у додатку AquaTrackMobile. Він забезпечує можливість отримувати список усіх даних сенсорів, отримувати окремі дані сенсора за ідентифікатором, додавати нові дані сенсора та видаляти існуючі дані сенсора. Ці методи також взаємодіють з віддаленим API за допомогою HTTP-клієнта Ktor, відправляючи GET, POST та DELETE запити та обробляючи відповіді у форматі JSON. Для обробки помилок під час виконання цих операцій реалізовано виняток SensorDataApiException.
ВИСНОВКИ


У ході розробки програмної системи для контролю акваріумів був проведений аналіз предметної області. Цей аналіз дозволив визначити головні задачі системи, які потрібно було вирішити. Основною метою системи було забезпечення ефективного контролю та моніторингу акваріумів.
У результаті роботи була розроблена програмна система, яка успішно виконує поставлені завдання. Програмна система має всі основні функції, які були заплановані на етапі постановки задачі. Користувачі системи мають змогу зареєструватися та увійти до неї, переглядати контролюємі акваріуми, маніпулювати мешканцями кожного з акваріумів, маніпулювати звітами досліджень та на основі них створювати і переглядати аналітичні звіти. Користувачі також можуть реєструвати і підключати свої сенсори, та налаштовувати графіки годування для акваріумів. Адміністратори ж можуть маніпулювати звичайними користувачами, маніпулювати акваріумами для кожного з користувачів.
У результаті розробки програмної системи була підготовлена пояснювальна записка з детальною документацією системи. Ця документація детально описує функціональність системи, архітектуру, проектування та використані технології. 
Загалом, розроблена програмна система для контролю акваріумів відповідає вимогам і досягає поставлених цілей. Вона забезпечує користувачам зручні та ефективні інструменти для контролю та моніторингом акваріумів.
 
ПЕРЕЛІК ДЖЕРЕЛ
1.	Wokwi – сайт для емуляції ІоТ-пристроїв: https://wokwi.com/ (дата звернення – 15.05.2024)
2.	Документація ASP.NET Core: https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-8.0&WT.mc_id=dotnet-35129-website&tabs=visual-studio\ (дата звернення 29.04.2024)
3.	Документація React.JS: https://react.dev/ (дата звернення – 20.05.2024)
4.	Документація Android: https://developer.android.com/develop (дата звернення 31.05.2024)
5.	Відео DEMO: https://youtu.be/qIzfsjIJIIM?si=yI6P76XynaQrDmyz
6.	Репозиторій проекту: https://github.com/NureVolnykovKyrylo/apzkr-pzpi-21-2-volnykov-kyrylo
7.	Файл із перевіркою пояснювальної записки на плагіат: https://drive.google.com/file/d/1EYTY1drw-uGursfgo1UcNNDf31wFS_LA/view?usp=sharing


 
ДОДАТОК А
Діаграми


А.1 UML діаграма прецедентів серверної частини
 
Рис.1 – UML діаграма прецедентів серверної частини
А.2 UML діаграма станів серверної частини

 
Рис.2 – UML діаграма станів серверної частини





А.3 ER-модель даних

 
Рис.3 – ER-модель даних


 
А.4 UML діаграма розгортання

 
Рис.4 – UML діаграма розгортання 
А.5 UML діаграма прецедентів IoT пристрою

 
Рис.5 – UML діаграма прецедентів IoT пристрою



А.6 Діаграма активності IoT пристрою
 
Рис.6 – Діаграма активності IoT пристрою
А.7 Діаграма взаємодії IoT пристрою

 
Рис.7 – Діаграма взаємодії IoT пристрою
А.8 Діаграма станів IoT пристрою

 
Рис.8 – Діаграма станів IoT пристрою

А.9 Схема фізичної моделі

 
Рис.9 – Схема фізичної моделі
 
А.10 UML діаграма прецедентів клієнтської веб-частини

 
Рис.1 – UML діаграма прецедентів клієнтської веб-частини





А.11 Діаграма активності клієнтської веб-частини

 
Рис.11 – Діаграма активності клієнтської веб-частини

А.12 Діаграма компонент клієнтської веб-частини

 
Рис.12 – Діаграма компонент клієнтської веб-частини






А.13 Діаграма станів клієнтської веб-частини

 
Рис.13 – Діаграма станів клієнтської веб-частини

А.14 UML діаграма прецедентів клієнтської мобільної частини

  
Рис.14 – UML діаграма прецедентів клієнтської мобільної частини


А.15 Діаграма активності клієнтської мобільної частини

  
Рис.15 – Діаграма активності клієнтської мобільної частини

А.16 Діаграма компонент клієнтської мобільної частини

  
Рис.16 – Діаграма компонент клієнтської мобільної частини




А.17 Діаграма станів клієнтської мобільної частини

  
Рис.17 – Діаграма станів клієнтської мобільної частини

 
ДОДАТОК Б
Код програми


Б.1 Код сервісу АnalysisReportService

1  using AutoMapper;
2  using Microsoft.Extensions.Hosting;
3  using System;
4  using System.Collections.Generic;
5  using System.Linq;
6  using System.Threading.Tasks;
7  using AquaTrack.Models;
8  using AquaTrack.Repositories.Interfaces;
9  using AquaTrack.Services.Interfaces;
10  using AquaTrack.ViewModels;
11  
12  namespace AquaTrack.Services
13  {
14      public class AnalysisReportService : IAnalysisReportService
15      {
16          private readonly IAnalysisReportRepository 
17  _analysisReportRepository;
18          private readonly IResearchReportRepository 
19  _researchReportRepository;
20          private readonly IAquariumRepository 
21  _aquariumRepository;
22          private readonly IInhabitantRepository 
23  _inhabitantRepository;
24          private readonly IMapper _mapper;
25  
26          public AnalysisReportService(
27              IAnalysisReportRepository analysisReportRepository,
28              IResearchReportRepository researchReportRepository,
29              IAquariumRepository aquariumRepository,
30              IInhabitantRepository inhabitantRepository,
31              IMapper mapper)
32          {
33              _analysisReportRepository = analysisReportRepository;
34              _researchReportRepository = researchReportRepository;
35              _aquariumRepository = aquariumRepository;
36              _inhabitantRepository = inhabitantRepository;
37              _mapper = mapper;
38          }
39  
40          public async Task<List<AnalysisReportViewModel>> 
41  GetAllAnalysisReports()
42          {
43              var analysisReports = await 
44  _analysisReportRepository.GetAllAnalysisReportsAsync();
45              var analysisReportViewModels = _mapper
46  .Map<List<AnalysisReportViewModel>>(analysisReports);
47              return analysisReportViewModels;
48          }
49  
50          public async Task<AnalysisReportViewModel> 
51  GetAnalysisReportById(int analysisReportId)
52          {
53              var analysisReport = await 
54  _analysisReportRepository.GetAnalysisReportByIdAsync(
55  analysisReportId);
56              var analysisReportViewModel = _mapper
57  .Map<AnalysisReportViewModel>(analysisReport);
58              return analysisReportViewModel;
59          }
60  
61          public async Task<AnalysisReportViewModel> 
62  UpdateAnalysisReport(AnalysisReportViewModel 
63  analysisReportViewModel)
64          {
65              var analysisReport = _mapper.Map<AnalysisReport>(
66  analysisReportViewModel);
67              var updatedAnalysisReport = await 
68  _analysisReportRepository
69  .UpdateAnalysisReportAsync(analysisReport);
70              var updatedAnalysisReportViewModel = 
71  _mapper.Map<AnalysisReportViewModel>(updatedAnalysisReport);
72              return updatedAnalysisReportViewModel;
73          }
74  
75          public async Task DeleteAnalysisReport(int 
76  analysisReportId)
77          {
78              await _analysisReportRepository
79  .DeleteAnalysisReportAsync(analysisReportId);
80          }
81  
82          public async Task<AnalysisReportViewModel> 
83  AddAnalysisReport(int researchReportId)
84          {
85              // Retrieve research report data needed for analysis
86              var researchReport = await _researchReportRepository
87  .GetResearchReportByIdAsync(researchReportId);
88              if (researchReport == null)
89              {
90                  return null;
91              }
92  
93  
94              // Retrieve sensor data from research report needed 
95  for analysis
96              var sensorData = researchReport.SensorData;
97              if (sensorData == null || sensorData.Count == 0)
98              {
99                  return null;
100              }
101  
102              // Retrieve aquarium information for analysis
103              var aquarium = await _aquariumRepository
104  .GetAquariumByIdAsync(researchReport.AquariumId);
105              if (researchReport == null)
106              {
107                  return null;
108              }
109              var aquariumViewModel = _mapper
110  .Map<AquariumViewModel>(aquarium);
111  
112              // Initialize dictionaries to store sensor data
113   grouped by sensor type
114              var movementSensorDataMap = 
115  new Dictionary<string, List<SensorData>>();
116              var videoSensorDataMap = 
117  new Dictionary<string, List<SensorData>>();
118  
119              var temperatureSensorDataMap = 
120  new Dictionary<string, List<SensorData>>();
121              var waterLevelSensorDataMap = 
122  new Dictionary<string, List<SensorData>>();
123              var aciditySensorDataMap = 
124  new Dictionary<string, List<SensorData>>();
125              var lightingSensorDataMap = 
126  new Dictionary<string, List<SensorData>>();
127  
128              // Group sensor data based on sensor type
129              foreach (var sensor in sensorData)
130              {
131                  switch (sensor.SensorType)
132                  {
133                      case SensorType.MovementSensor when aquarium
134  .Inhabitants.Any(a => a.Name == sensor.SensorIdentificator):
135                          AddToSensorDataMap(movementSensorDataMap, 
136  sensor.SensorIdentificator, sensor);
137                          break;
138  
139                      case SensorType.VideoSensor when aquarium
140  .Inhabitants.Any(a => a.Name == sensor.SensorIdentificator):
141                          AddToSensorDataMap(videoSensorDataMap, 
142  sensor.SensorIdentificator, sensor);
143                          break;
144  
145                      case SensorType.TemperatureSensor:
146                          if (sensor.SensorIdentificator == 
147  aquarium.AquariumType)
148                          {
149                              AddToSensorDataMap(
150  temperatureSensorDataMap, sensor.SensorIdentificator, sensor);
151                          }
152                          break;
153                      case SensorType.WaterLevelSensor:
154                          if (sensor.SensorIdentificator == 
155  aquarium.AquariumType)
156                          {
157                              AddToSensorDataMap(
158  waterLevelSensorDataMap, sensor.SensorIdentificator, sensor);
159                          }
160                          break;
161                      case SensorType.AciditySensor:
162                          if (sensor.SensorIdentificator == 
163  aquarium.AquariumType)
164                          {
165                              AddToSensorDataMap(
166  aciditySensorDataMap, sensor.SensorIdentificator, sensor);
167                          }
168                          break;
169                      case SensorType.LightingSensor:
170                          if (sensor.SensorIdentificator == 
171  aquarium.AquariumType)
172                          {
173                              AddToSensorDataMap(
174  lightingSensorDataMap, sensor.SensorIdentificator, sensor);
175                          }
176                          break;
177  
178                      default:
179                          break;
180                  }
181              }
182  
183              var analysedTrends = "";
184  
185              // Perform analysis and generate indicators for 
186  different aspects
187              var movementIndicators = AnalyzeInhabitantActivity(
188  movementSensorDataMap, aquarium.Inhabitants);
189              var conditionIndicators = AnalyzeInhabitantCondition(
190  videoSensorDataMap, aquarium.Inhabitants);
191  
192              var temperatureIndicators = 
193  AnalyzeAquariumTemperature(temperatureSensorDataMap, 
194  aquariumViewModel);
195              var waterLevelIndicators = 
196  AnalyzeAquariumWaterLevel(waterLevelSensorDataMap, 
197  aquariumViewModel);
198              var acidityIndicators = 
199  AnalyzeAquariumAcidity(aciditySensorDataMap, aquariumViewModel);
200              var lightingIndicators = 
201  AnalyzeAquariumLighting(lightingSensorDataMap, aquariumViewModel);
202  
203              // Construct conclusions based on the 
204  analyzed indicators
205              if (movementIndicators.Any())
206              {
207                  analysedTrends += movementIndicators.Last();
208                  movementIndicators.RemoveAt(
209  movementIndicators.Count - 1);
210              }
211  
212              if (conditionIndicators.Any())
213              {
214                  analysedTrends += conditionIndicators.Last();
215                  conditionIndicators.RemoveAt(
216  conditionIndicators.Count - 1);
217              }
218  
219              if (temperatureIndicators.Any())
220              {
221                  analysedTrends += temperatureIndicators.Last();
222                  temperatureIndicators.RemoveAt(
223  temperatureIndicators.Count - 1);
224              }
225  
226              if (waterLevelIndicators.Any())
227              {
228                  analysedTrends += waterLevelIndicators.Last();
229                  waterLevelIndicators.RemoveAt(
230  waterLevelIndicators.Count - 1);
231              }
232  
233              if (acidityIndicators.Any())
234              {
235                  analysedTrends += acidityIndicators.Last();
236                  acidityIndicators.RemoveAt(
237  acidityIndicators.Count - 1);
238              }
239  
240              if (lightingIndicators.Any())
241              {
242                  analysedTrends += lightingIndicators.Last();
243                  lightingIndicators.RemoveAt(
244  lightingIndicators.Count - 1);
245              }
246  
247              // Extract most common indicators for each aspect
248              var mostCommonMovementIndicator = movementIndicators
249  .GroupBy(x => x)
250                  .OrderByDescending(grp => grp.Count())
251                  .Select(grp => grp.Key)
252                  .FirstOrDefault();
253  
254              var mostCommonConditionIndicator = conditionIndicators
255  .GroupBy(x => x)
256                  .OrderByDescending(grp => grp.Count())
257                  .Select(grp => grp.Key)
258                  .FirstOrDefault();
259  
260              var mostCommonTemperatureIndicator = 
261  temperatureIndicators.GroupBy(x => x)
262                  .OrderByDescending(grp => grp.Count())
263                  .Select(grp => grp.Key)
264                  .FirstOrDefault();
265  
266              var mostCommonWaterLevelIndicator = 
267  waterLevelIndicators.GroupBy(x => x)
268                  .OrderByDescending(grp => grp.Count())
269                  .Select(grp => grp.Key)
270                  .FirstOrDefault();
271  
272              var mostCommonAcidityIndicator = 
273  acidityIndicators.GroupBy(x => x)
274                  .OrderByDescending(grp => grp.Count())
275                  .Select(grp => grp.Key)
276                  .FirstOrDefault();
277  
278              var mostCommonLightingIndicator = 
279  lightingIndicators.GroupBy(x => x)
280                  .OrderByDescending(grp => grp.Count())
281                  .Select(grp => grp.Key)
282                  .FirstOrDefault();
283  
284              var recommendations = "";
285  
286              // Generate recommendations based on conclusions
287              recommendations += $"Recommendations on inhabitant 
288  activity: {GetRecommendationFromConclusion(
289  mostCommonMovementIndicator)} n";
290              recommendations += $"Recommendations on inhabitant 
291  condition: {GetRecommendationFromConclusion(
292  mostCommonConditionIndicator)} n";
293              recommendations += $"Recommendations on aquarium 
294  temperature: {GetRecommendationFromConclusion(
295  mostCommonTemperatureIndicator)} n";
296              recommendations += $"Recommendations on aquarium 
297  acidity: {GetRecommendationFromConclusion(
298  mostCommonWaterLevelIndicator)} n";
299              recommendations += $"Recommendations on aquarium 
300  water level: {GetRecommendationFromConclusion(
301  mostCommonAcidityIndicator)} n";
302              recommendations += $"Recommendations on aquarium 
303  lighting: {GetRecommendationFromConclusion(
304  mostCommonLightingIndicator)} n";
305  
306              var analysisReport = new AnalysisReport
307              {
308                  ResearchReportId = researchReportId,
309                  CreationDate = DateTime.UtcNow,
310                  Title = "Analysis Report",
311                  IdentifiedTrends = analysedTrends,
312                  Recommendations = recommendations
313              };
314  
315              var addedAnalysisReport = await 
316  _analysisReportRepository.AddAnalysisReportAsync(analysisReport);
317              var addedAnalysisReportViewModel = 
318  _mapper.Map<AnalysisReportViewModel>(addedAnalysisReport);
319              return addedAnalysisReportViewModel;
320          }
321  
322          void AddToSensorDataMap(Dictionary<string, 
323  List<SensorData>> sensorDataMap, string key, SensorData sensor)
324          {
325              if (!sensorDataMap.ContainsKey(key))
326              {
327                  sensorDataMap[key] = new List<SensorData>();
328              }
329  
330              sensorDataMap[key].Add(sensor);
331          }
332  
333          public string GetRecommendationFromConclusion(
334  string conclusion)
335          {
336              if (conclusion != null)
337              {
338                  if (conclusion == "decreased")
339                  {
340                      return "There is a significant decline, 
341  take action";
342                  }
343                  else if (conclusion == "increased")
344                  {
345                      return "Significant growth is observed, 
346  take action";
347                  }
348                  else if (conclusion == "normal")
349                  {
350                      return "No significant changes observed";
351                  }
352              }
353              return "";
354          }
355  
356          // Analyze methods
357          public List<string> AnalyzeInhabitantActivity(
358  Dictionary<string, List<SensorData>> movementSensorDataMap, 
359  List<Inhabitant> inhabitants)
360          {
361              var activityIndicators = new List<string>();
362              var analysedTrends = "Inhabitant activity trends: n";
363  
364              foreach (var inhabitant in inhabitants)
365              {
366                  if (movementSensorDataMap.TryGetValue(inhabitant
367  .Name, out var movementSensorData))
368                  {
369                      if (double.TryParse(inhabitant.Behavior, 
370  out double behaviorValue))
371                      {
372                          var averageMovementValue = 
373  movementSensorData.Average(s => s.SensorValue);
374                          string movementStatus;
375  
376                          if (Math.Abs(averageMovementValue - 
377  behaviorValue) < 10)
378                          {
379                              movementStatus = "on normal value";
380                              activityIndicators.Add("normal");
381                          }
382                          else if (Math.Abs(
383  averageMovementValue - behaviorValue) > 10 && 
384  averageMovementValue < behaviorValue)
385                          {
386                              movementStatus = "decreased";
387                              activityIndicators.Add("decreased");
388                          }
389                          else
390                          {
391                              movementStatus = "increased";
392                              activityIndicators.Add("increased");
393                          }
394  
395                          analysedTrends += $"{inhabitant.Name} 
396  activity {movementStatus} based on research analysis. n";
397                      }
398                  }
399              }
400              activityIndicators.Add(analysedTrends);
401              return activityIndicators;
402          }
403  
404          public List<string> AnalyzeInhabitantCondition(
405  Dictionary<string, List<SensorData>> videoSensorDataMap, 
406  List<Inhabitant> inhabitants)
407          {
408              var conditionIndicators = new List<string>();
409  
410              var analysedTrends = "Inhabitant condition trends: n";
411  
412              foreach (var inhabitant in inhabitants)
413              {
414                  if (videoSensorDataMap.TryGetValue(
415  inhabitant.Name, out var videoSensorData))
416                  {
417                      if (double.TryParse(inhabitant.Condition, 
418  out double conditionValue))
419                      {
420                          var averageConditionValue = 
421  videoSensorData.Average(s => s.SensorValue);
422  
423                          string conditionStatus;
424  
425                          if (Math.Abs(
426  averageConditionValue - conditionValue) < 10)
427                          {
428                              conditionStatus = "normal";
429                              conditionIndicators.Add("normal");
430                          }
431                          else if (Math.Abs(
432  averageConditionValue - conditionValue) > 10 &&
433                              averageConditionValue < conditionValue)
434                          {
435                              conditionStatus = "worse";
436                              conditionIndicators.Add("decreased");
437                          }
438                          else
439                          {
440                              conditionStatus = "abnormal";
441                              conditionIndicators.Add("increased");
442                          }
443  
444                          analysedTrends += $"{inhabitant.Name} 
445  condition is {conditionStatus} based on research analysis. n";
446                      }
447                  }
448              }
449              conditionIndicators.Add(analysedTrends);
450              return conditionIndicators;
451          }
452  
453  
454          public enum AquariumProperty { Temperature, WaterLevel, 
455  Acidity, Lighting }
456  
457          private float GetAquariumProperty(
458  AquariumProperty property, AquariumViewModel aquariumViewModel)
459          {
460              // Implement logic to retrieve property value based 
461  on property enum value
462              switch (property)
463              {
464                  case AquariumProperty.Temperature:
465                      return (float)aquariumViewModel.Temperature;
466                  case AquariumProperty.WaterLevel:
467                      return (float)aquariumViewModel.WaterLevel;
468                  case AquariumProperty.Acidity:
469                      return (float)aquariumViewModel.Acidity;
470                  case AquariumProperty.Lighting:
471                      return (float)aquariumViewModel.Lighting;
472                  default:
473                      throw new ArgumentException(
474  $"Invalid property: {property}");
475              }
476          }
477  
478          public List<string> 
479  AnalyzeAquariumProperty(AquariumProperty property,
480  Dictionary<string, List<SensorData>> sensorDataMap,
481  AquariumViewModel aquariumViewModel)
482          {
483              var indicators = new List<string>();
484              var analysedTrends = $"Aquarium {property} trends: n";
485  
486              if (sensorDataMap.TryGetValue(
487  aquariumViewModel.AquariumType, out var sensorData))
488              {
489                  var averageValue = sensorData
490  .Average(s => s.SensorValue);
491                  string conditionStatus;
492  
493                  var propertyValue = 
494  GetAquariumProperty(property, aquariumViewModel);
495  
496                  if (Math.Abs(averageValue - propertyValue) < 10)
497                  {
498                      conditionStatus = "normal";
499                      indicators.Add("normal");
500                  }
501                  else if (Math.Abs(
502  averageValue - propertyValue) > 10 &&
503                           averageValue < propertyValue)
504                  {
505                      conditionStatus = "decreased";
506                      indicators.Add("decreased");
507                  }
508                  else
509                  {
510                      conditionStatus = "increased significantly";
511                      indicators.Add("increased");
512                  }
513  
514                  analysedTrends += $"{
515  aquariumViewModel.AquariumType} {property.ToString()} 
516  is {conditionStatus} based on research analysis. n";
517              }
518  
519              indicators.Add(analysedTrends);
520              return indicators;
521          }
522  
523          public List<string> AnalyzeAquariumTemperature(
524  Dictionary<string, List<SensorData>> temperatureSensorDataMap, 
525  AquariumViewModel aquariumViewModel)
526          {
527              return AnalyzeAquariumProperty(AquariumProperty
528  .Temperature, temperatureSensorDataMap, aquariumViewModel);
529          }
530  
531          public List<string> AnalyzeAquariumWaterLevel(
532  Dictionary<string, List<SensorData>> waterLevelSensorDataMap, 
533  AquariumViewModel aquariumViewModel)
534          {
535              return AnalyzeAquariumProperty(AquariumProperty
536  .WaterLevel, waterLevelSensorDataMap, aquariumViewModel);
537          }
538  
539          public List<string> AnalyzeAquariumAcidity(
540  Dictionary<string, List<SensorData>> aciditySensorDataMap, 
541  AquariumViewModel aquariumViewModel)
542          {
543              return AnalyzeAquariumProperty(AquariumProperty
544  .Acidity, aciditySensorDataMap, aquariumViewModel);
545          }
546  
547          public List<string> AnalyzeAquariumLighting(
548  Dictionary<string, List<SensorData>> lightingSensorDataMap, 
549  AquariumViewModel aquariumViewModel)
550          {
551              return AnalyzeAquariumProperty(AquariumProperty
552  .Lighting, lightingSensorDataMap, aquariumViewModel);
553          }
554  
555      }
556  
557  }

Б.2 Код сервісу AquariumService

1  using AquaTrack.Models;
2  using AquaTrack.Repositories.Interfaces;
3  using AquaTrack.Services.Interfaces;
4  using AquaTrack.Utils;
5  using AquaTrack.ViewModels;
6  using AutoMapper;
7  
8  namespace AquaTrack.Services
9  {
10      public class AquariumService : IAquariumService
11      {
12          private readonly IAuthentificationService _authService;
13          private readonly IAquariumRepository _aquariumRepository;
14          private readonly IMapper _mapper;
15          private readonly IHttpContextAccessor _httpContextAccessor;
16  
17          public AquariumService(
18              IAuthentificationService authService,
19              IAquariumRepository aquariumRepository,
20              IMapper mapper,
21              IHttpContextAccessor httpContextAccessor)
22          {
23              _authService = authService;
24              _aquariumRepository = aquariumRepository;
25              _mapper = mapper;
26              _httpContextAccessor = httpContextAccessor;
27          }
28  
29          public async Task<AquariumViewModel> GetAquariumById(int 
30  aquariumId)
31          {
32              var aquarium = await _aquariumRepository
33  .GetAquariumByIdAsync(aquariumId);
34              if (aquarium == null)
35              {
36                  return null;
37              }
38  
39              var aquariumViewModel = _mapper.Map
40  <AquariumViewModel>(aquarium);
41              return aquariumViewModel;
42          }
43  
44          public async Task<List<AquariumViewModel>> 
45  GetAquariumsForCurrentUser()
46          {
47              var user = await _authService.GetCurrentUser();
48              if (user == null)
49              {
50                  return null;
51              }
52  
53              var aquariums = await _aquariumRepository
54  .GetAquariumsByUserIdAsync(user.UserId);
55              var aquariumViewModels = _mapper
56  .Map<List<AquariumViewModel>>(aquariums);
57              return aquariumViewModels;
58          }
59  
60          public async Task<List<AquariumViewModel>> 
61  GetAquariumsForUser(int userId)
62          {
63              var currentUserRole = UserAccessUtil
64  .GetCurrentUserRole(_httpContextAccessor);
65              if (currentUserRole != Role.Admin)
66              {
67                  return null;
68              }
69  
70              var aquariums = await _aquariumRepository
71  .GetAquariumsByUserIdAsync(userId);
72              var aquariumViewModels = _mapper
73  .Map<List<AquariumViewModel>>(aquariums);
74              return aquariumViewModels;
75          }
76  
77          public async Task<AquariumViewModel> 
78  AddAquariumForUser(AquariumViewModel aquariumViewModel, int userId)
79          {
80              var currentUserRole = UserAccessUtil
81  .GetCurrentUserRole(_httpContextAccessor);
82              if (currentUserRole != Role.Admin)
83              {
84                  return null;
85              }
86  
87              var aquarium = _mapper.Map<Aquarium>(aquariumViewModel);
88              aquarium.UserId = userId;
89  
90              var addedAquarium = await _aquariumRepository
91  .AddAquariumAsync(aquarium);
92              var addedAquariumViewModel = _mapper
93  .Map<AquariumViewModel>(addedAquarium);
94              return addedAquariumViewModel;
95          }
96  
97          public async Task<AquariumViewModel> 
98  UpdateAquariumForUser(AquariumViewModel aquariumViewModel, int userId)
99          {
100              var currentUserRole = UserAccessUtil
101  .GetCurrentUserRole(_httpContextAccessor);
102              if (currentUserRole != Role.Admin)
103              {
104                  return null;
105              }
106  
107              var aquarium = await _aquariumRepository
108  .GetAquariumByIdAsync(aquariumViewModel.AquariumId);
109              if (aquarium == null || aquarium.UserId != userId)
110              {
111                  return null;
112              }
113  
114              _mapper.Map(aquariumViewModel, aquarium);
115              var updatedAquarium = await _aquariumRepository
116  .UpdateAquariumAsync(aquarium);
117              var updatedAquariumViewModel = _mapper
118  .Map<AquariumViewModel>(updatedAquarium);
119              return updatedAquariumViewModel;
120          }
121  
122          public async Task<bool> 
123  DeleteAquariumForUser(int aquariumId)
124          {
125              var currentUserRole = UserAccessUtil
126  .GetCurrentUserRole(_httpContextAccessor);
127              if (currentUserRole != Role.Admin)
128              {
129                  return false;
130              }
131              var user = await _authService.GetCurrentUser();
132              if (user == null)
133              {
134                  return false;
135              }
136              var aquarium = await _aquariumRepository
137  .GetAquariumByIdAsync(aquariumId);
138              if (aquarium == null || aquarium.UserId != user.UserId)
139              {
140                  return false;
141              }
142              await _aquariumRepository
143  .DeleteAquariumAsync(aquariumId);
144              return true;
145          }
146      }

Б.3 Код сервісу AuthentificationService

1 using AutoMapper;
2 using Microsoft.AspNetCore.Mvc;
3 using Microsoft.AspNetCore.Http;
4 using Microsoft.VisualBasic;
5 using AquaTrack.Models;
6 using AquaTrack.Repositories.Interfaces;
7 using AquaTrack.Services.Interfaces;
8 using AquaTrack.ViewModels;
9 using BCrypt.Net;
10 using AquaTrack.Utils;
11
12
13 namespace AquaTrack.Services
14 {
15    public class AuthentificationService : IAuthentificationService
16    {
17        private readonly IMapper _mapper;
18        private readonly IUserRepository _userRepository;
19        private readonly IHttpContextAccessor _httpContextAccessor;
20
21        public AuthentificationService(
22            IMapper mapper,
23            IUserRepository userRepository,
24            IHttpContextAccessor httpContextAccessor)
25        {
26            _mapper = mapper;
27            _userRepository = userRepository;
28            _httpContextAccessor = httpContextAccessor;
29        }
30
31        public async Task<User?> GetCurrentUser()
32        {
33            var currentUserId = 34 _httpContextAccessor.HttpContext?.Request.Cookies["userId"];
35            if (currentUserId == null || !int.TryParse(currentUserId, out 36 int userId))
37            {
38                return null;
39            }
40
41            var user = await _userRepository.GetUserByIdAsync(userId);
42            return user;
43        }
44
45        public async Task<UserViewModel> Login(string email, string 46 password)
47        {
48            var user = await _userRepository.GetUserByEmailAsync(email);
49
50            if (user == null || !BCrypt.Net.BCrypt.Verify(password, 51 user.Password))
52            {
53                return null;
54            }
55
56            var cookieOptions = new CookieOptions
57            {
58                Expires = DateTimeOffset.Now.AddDays(7)
59            };
60
61            62 _httpContextAccessor.HttpContext.Response.Cookies.Append("role", 63 user.Role.ToString(), cookieOptions);
64            65 _httpContextAccessor.HttpContext.Response.Cookies.Append("userId", 66 user.UserId.ToString(), cookieOptions);
67
68            var userViewModel = _mapper.Map<UserViewModel>(user);
69            return userViewModel;
70        }
71
72        public async Task<bool> Logout()
73        {
74            if (_httpContextAccessor.HttpContext == null)
75            {
76                return false;
77            }
78
79            80 _httpContextAccessor.HttpContext.Response.Cookies.Delete("role");
81            82 _httpContextAccessor.HttpContext.Response.Cookies.Delete("userId");
83            return true;
84        }
85
86        public async Task<UserViewModel> RegisterUser(UserRegisterViewModel 87 model)
88        {
89            await Validate(_mapper.Map<UserViewModel>(model), true);
90            model.Password = 91 BCrypt.Net.BCrypt.HashPassword(model.Password);
92
93            var user = _mapper.Map<User>(model);
94            user.Role = Role.User;
95
96            var createUserResult = await 97 _userRepository.AddUserAsync(user);
98
99            var cookieOptions = new CookieOptions
100            {
101                Expires = DateTimeOffset.Now.AddDays(7)
102            };
103
104            105 _httpContextAccessor.HttpContext.Response.Cookies.Append("role", 106 user.Role.ToString(), cookieOptions);
107            108 _httpContextAccessor.HttpContext.Response.Cookies.Append("userId", 109 user.UserId.ToString(), cookieOptions);
110
111            var userViewModel = 112 _mapper.Map<UserViewModel>(createUserResult);
113            return userViewModel;
114        }
115
116        public async Task<UserViewModel> 117 UpdateUserInfo(UserUpdateViewModel model)
118        {
119            var user = await GetCurrentUser();
120            if (user == null)
121            {
122                return null;
123            }
124
125            _mapper.Map(model, user);
126
127            await Validate(_mapper.Map<UserViewModel>(user), false);
128
129            user.Password = BCrypt.Net.BCrypt.HashPassword(user.Password);
130
131            var updateResult = await 132 _userRepository.UpdateUserAsync(user);
133            if (updateResult == null)
134            {
135                return null;
136            }
137
138            var updatedUserViewModel = 139 _mapper.Map<UserViewModel>(updateResult);
140            return updatedUserViewModel;
141        }
142
143        public async Task<UserViewModel?> GetCurrentUserInfo()
144        {
145            var user = await GetCurrentUser();
146            if (user == null)
147            {
148                return null;
149            }
150
151            var userViewModel = _mapper.Map<UserViewModel>(user);
152            return userViewModel;
153        }
154
155        public async Task Validate(UserViewModel user, bool isNewUser)
156        {
157            if (string.IsNullOrEmpty(user.Email))
158            {
159                throw new ArgumentException("Email is required.");
160            }
161
162            if (isNewUser)
163            {
164                var existingUser = await 165 _userRepository.GetUserByEmailAsync(user.Email);
166                if (existingUser != null)
167                {
168                    throw new ArgumentException("Email is already 169 registered.");
170                }
171
172                if (string.IsNullOrEmpty(user.Password))
173                {
174                    throw new ArgumentException("Password is required.");
175                }
176
177                if (user.Password.Length < 6)
178                {
179                    throw new ArgumentException("Password should be at 180 least 6 characters long.");
181                }
182            }
183
184            if (string.IsNullOrEmpty(user.FirstName))
185            {
186                throw new ArgumentException("First name is required.");
187            }
188
189            if (!IsValidEmail(user.Email))
190            {
191                throw new ArgumentException("Invalid email format.");
192            }
193        }
194
195        private bool IsValidEmail(string email)
196        {
197            try
198            {
199                var addr = new System.Net.Mail.MailAddress(email);
200                return addr.Address == email;
201            }
202            catch
203            {
204                return false;
205            }
206        }
207
208        public async Task<List<UserViewModel>> GetAllUsers()
209        {
210            var userRole = 211 UserAccessUtil.GetCurrentUserRole(_httpContextAccessor);
212            if (userRole != Role.Admin)
213            {
214                return null;
215            }
216
217            var users = await _userRepository.GetAllUsersAsync();
218            var userViewModels = _mapper.Map<List<UserViewModel>>(users);
219            return userViewModels;
220        }
221
222        public async Task<bool> DeleteUser(int userId)
223        {
224            var userRole = 225 UserAccessUtil.GetCurrentUserRole(_httpContextAccessor);
226            if (userRole != Role.Admin)
227            {
228                return false;
229            }
230
231            var user = await _userRepository.GetUserByIdAsync(userId);
232            if (user == null)
233            {
234                return false;
235            }
236
237            await _userRepository.DeleteUserAsync(userId);
238            return true;
239        }
240
241        public async Task<UserViewModel> AddUser(UserUtilityViewModel 242 model)
243        {
244            var userRole = 245 UserAccessUtil.GetCurrentUserRole(_httpContextAccessor);
246            if (userRole != Role.Admin)
247            {
248                return null;
249            }
250
251            var existingUser = await 252_userRepository.GetUserByEmailAsync(model.Email);
253            if (existingUser != null)
254            {
255                throw new ArgumentException("Email is already 256 registered.");
257            }
258
259            var user = _mapper.Map<User>(model);
260            user.Password = 261 BCrypt.Net.BCrypt.HashPassword(model.Password);
262            user.Role = Role.User;
263
264            var createdUser = await _userRepository.AddUserAsync(user);
265            var userViewModel = _mapper.Map<UserViewModel>(createdUser);
266            return userViewModel;
267        }
268
269        public async Task<UserViewModel> UpdateUser(int userId, 270 UserUtilityViewModel model)
271        {
272            var userRole = 273 UserAccessUtil.GetCurrentUserRole(_httpContextAccessor);
274            if (userRole != Role.Admin)
275            {
276                return null;
277            }
278
279            var user = await _userRepository.GetUserByIdAsync(userId);
280            if (user == null)
281            {
282                return null;
283            }
284
285            _mapper.Map(model, user);
286
287            user.Password = 288 BCrypt.Net.BCrypt.HashPassword(model.Password);
289
290            var updatedUser = await _userRepository.UpdateUserAsync(user);
291            var updatedUserViewModel = 292 _mapper.Map<UserViewModel>(updatedUser);
293            return updatedUserViewModel;
294        }
295    }
296}

Б.4 Код сервісу FeedingScheduleService

1  using AquaTrack.Models;
2  using AquaTrack.Repositories.Interfaces;
3  using AquaTrack.Services.Interfaces;
4  using AquaTrack.ViewModels;
5  using AutoMapper;
6  
7  namespace AquaTrack.Services
8  {
9      public class FeedingScheduleService : IFeedingScheduleService
10      {
11          private readonly IAuthentificationService _authService;
12          private readonly IFeedingScheduleRepository 
13  _feedingScheduleRepository;
14          private readonly IAquariumRepository _aquariumRepository;
15          private readonly IMapper _mapper;
16  
17          public FeedingScheduleService(
18              IAuthentificationService authService,
19              IFeedingScheduleRepository feedingScheduleRepository,
20              IAquariumRepository aquariumRepository,
21              IMapper mapper)
22          {
23              _authService = authService;
24              _feedingScheduleRepository = feedingScheduleRepository;
25              _aquariumRepository = aquariumRepository;
26              _mapper = mapper;
27          }
28  
29          public async Task<List<FeedingScheduleViewModel>> 
30  GetFeedingSchedulesForCurrentUser()
31          {
32              var user = await _authService.GetCurrentUser();
33              if (user == null)
34              {
35                  return null;
36              }
37  
38              var feedingSchedules = 
39  await _feedingScheduleRepository
40  . GetFeedingSchedulesByUserIdAsync (user.UserId);
41              var feedingScheduleViewModels = 
42  _mapper.Map<List<FeedingScheduleViewModel>>(feedingSchedules);
43              return feedingScheduleViewModels;
44          }
45  
46          public async Task<FeedingScheduleViewModel> 
47  GetFeedingScheduleById(int feedingScheduleId)
48          {
49              var feedingSchedule = 
50  await _feedingScheduleRepository
51  .GetFeedingScheduleByIdAsync(feedingScheduleId);
52              if (feedingSchedule == null)
53              {
54                  return null;
55              }
56  
57              var feedingScheduleViewModel = 
58  _mapper.Map<FeedingScheduleViewModel>(feedingSchedule);
59              return feedingScheduleViewModel;
60          }
61  
62          public async Task<FeedingScheduleViewModel> 
63  AddFeedingScheduleForCurrentUser(
64  FeedingScheduleViewModel feedingScheduleViewModel)
65          {
66              var user = await _authService.GetCurrentUser();
67              if (user == null)
68              {
69                  return null;
70              }
71  
72              var aquarium = await _aquariumRepository
73  .GetAquariumByIdAsync(feedingScheduleViewModel.AquariumId);
74              if (aquarium == null || aquarium.UserId != user.UserId)
75              {
76                  return null; // The user doesn't have 
77  access to the specified aquarium
78              }
79  
80              var feedingSchedule = _mapper.Map<FeedingSchedule>(
81  feedingScheduleViewModel);
82  
83              var addedFeedingSchedule = 
84  await _feedingScheduleRepository
85  .AddFeedingScheduleAsync(feedingSchedule);
86              var addedFeedingScheduleViewModel = 
87  _mapper.Map<FeedingScheduleViewModel>(addedFeedingSchedule);
88              return addedFeedingScheduleViewModel;
89          }
90  
91          public async Task<FeedingScheduleViewModel> 
92  UpdateFeedingScheduleForCurrentUser(
93  FeedingScheduleViewModel feedingScheduleViewModel)
94          {
95              var user = await _authService.GetCurrentUser();
96              if (user == null)
97              {
98                  return null;
99              }
100  
101              var feedingSchedule = 
102  await _feedingScheduleRepository
103  .GetFeedingScheduleByIdAsync(feedingScheduleViewModel
104  .FeedingScheduleId);
105              if (feedingSchedule == null || 
106  feedingSchedule.Aquarium.UserId != user.UserId)
107              {
108                  return null;
109              }
110  
111              _mapper.Map(feedingScheduleViewModel, 
112  feedingSchedule);
113              var updatedFeedingSchedule = 
114  await _feedingScheduleRepository
115  .UpdateFeedingScheduleAsync(feedingSchedule);
116              var updatedFeedingScheduleViewModel = 
117  _mapper.Map<FeedingScheduleViewModel>(updatedFeedingSchedule);
118              return updatedFeedingScheduleViewModel;
119          }
120  
121          public async Task<bool> 
122  DeleteFeedingScheduleForCurrentUser(int feedingScheduleId)
123          {
124              var user = await _authService.GetCurrentUser();
125              if (user == null)
126              {
127                  return false;
128              }
129  
130              var feedingSchedule = 
131  await _feedingScheduleRepository.GetFeedingScheduleByIdAsync(
132  feedingScheduleId);
133              if (feedingSchedule == null || 
134  feedingSchedule.Aquarium.UserId != user.UserId)
135              {
136                  return false;
137              }
138  
139              await _feedingScheduleRepository
140  .DeleteFeedingScheduleAsync(feedingScheduleId);
141              return true;
142          }
143      }
144  }

Б.5 Код сервісу InhabitantService

1  using AquaTrack.Models;
2  using AquaTrack.Repositories;
3  using AquaTrack.Repositories.Interfaces;
4  using AquaTrack.Services.Interfaces;
5  using AquaTrack.ViewModels;
6  using AutoMapper;
7  
8  namespace AquaTrack.Services
9  {
10      public class InhabitantService : IInhabitantService
11      {
12          private readonly IAuthentificationService _authService;
13          private readonly IInhabitantRepository 
14  _inhabitantRepository;
15          private readonly IAquariumRepository _aquariumRepository;
16          private readonly IMapper _mapper;
17  
18          public InhabitantService(
19              IAuthentificationService authService,
20              IInhabitantRepository inhabitantRepository,
21              IAquariumRepository aquariumRepository,
22              IMapper mapper)
23          {
24              _authService = authService;
25              _aquariumRepository = aquariumRepository;
26              _inhabitantRepository = inhabitantRepository;
27              _mapper = mapper;
28          }
29  
30          public async Task<List<InhabitantViewModel>> 
31  GetInhabitantsByAquariumId(int aquariumId)
32          {
33              var user = await _authService.GetCurrentUser();
34              if (user == null)
35              {
36                  return null;
37              }
38  
39              var inhabitants = await _inhabitantRepository
40  .GetInhabitantsByAquariumIdAsync(aquariumId);
41              var inhabitantViewModels = _mapper
42  .Map<List<InhabitantViewModel>>(inhabitants);
43              return inhabitantViewModels;
44          }
45  
46          public async Task<InhabitantViewModel> 
47  GetInhabitantById(int inhabitantId)
48          {
49              var inhabitant = await _inhabitantRepository
50  .GetInhabitantByIdAsync(inhabitantId);
51              if (inhabitant == null)
52              {
53                  return null;
54              }
55  
56              var inhabitantViewModel = _mapper
57  .Map<InhabitantViewModel>(inhabitant);
58              return inhabitantViewModel;
59          }
60  
61          public async Task<InhabitantViewModel> 
62  AddInhabitantForCurrentUser(InhabitantViewModel 
63  inhabitantViewModel)
64          {
65              var user = await _authService.GetCurrentUser();
66              if (user == null)
67              {
68                  return null;
69              }
70  
71              var aquarium = await _aquariumRepository
72  .GetAquariumByIdAsync(inhabitantViewModel.AquariumId);
73              if (aquarium == null || aquarium.UserId != user.UserId)
74              {
75                  return null; // The user doesn't have access 
76  to the specified aquarium
77              }
78  
79              var inhabitant = _mapper.Map<Inhabitant>(
80  inhabitantViewModel);
81  
82              var addedInhabitant = await _inhabitantRepository
83  .AddInhabitantAsync(inhabitant);
84              var addedInhabitantViewModel = _mapper
85  .Map<InhabitantViewModel>(addedInhabitant);
86              return addedInhabitantViewModel;
87          }
88  
89          public async Task<InhabitantViewModel> 
90  UpdateInhabitantForCurrentUser(
91  InhabitantViewModel inhabitantViewModel)
92          {
93              var user = await _authService.GetCurrentUser();
94              if (user == null)
95              {
96                  return null;
97              }
98  
99              var inhabitant = await _inhabitantRepository
100  .GetInhabitantByIdAsync(inhabitantViewModel.InhabitantId);
101              if (inhabitant == null || inhabitant.Aquarium
102  .UserId != user.UserId)
103              {
104                  return null;
105              }
106  
107              _mapper.Map(inhabitantViewModel, inhabitant);
108              var updatedInhabitant = await _inhabitantRepository
109  .UpdateInhabitantAsync(inhabitant);
110              var updatedInhabitantViewModel = _mapper
111  .Map<InhabitantViewModel>(updatedInhabitant);
112              return updatedInhabitantViewModel;
113          }
114  
115          public async Task<bool> DeleteInhabitantForCurrentUser(
116  int inhabitantId)
117          {
118              var user = await _authService.GetCurrentUser();
119              if (user == null)
120              {
121                  return false;
122              }
123  
124              var inhabitant = await _inhabitantRepository
125  .GetInhabitantByIdAsync(inhabitantId);
126              if (inhabitant == null || inhabitant.Aquarium
127  .UserId != user.UserId)
128              {
129                  return false;
130              }
131  
132              await _inhabitantRepository.DeleteInhabitantAsync(
133  inhabitantId);
134              return true;
135          }
136      }
137  }

Б.6 Код сервісу ResearchReportService

1  using AquaTrack.Models;
2  using AquaTrack.Repositories.Interfaces;
3  using AquaTrack.Services.Interfaces;
4  using AquaTrack.ViewModels;
5  using AutoMapper;
6  
7  namespace AquaTrack.Services
8  {
9      public class ResearchReportService : IResearchReportService
10      {
11          private readonly IResearchReportRepository 
12  _researchReportRepository;
13          private readonly IMapper _mapper;
14  
15          public ResearchReportService(
16  IResearchReportRepository researchReportRepository, IMapper mapper)
17          {
18              _researchReportRepository = researchReportRepository;
19              _mapper = mapper;
20          }
21  
22          public async Task<List<ResearchReportViewModel>> 
23  GetAllResearchReports()
24          {
25              var reports = await _researchReportRepository
26  .GetAllResearchReportsAsync();
27              var reportViewModels = _mapper
28  .Map<List<ResearchReportViewModel>>(reports);
29              return reportViewModels;
30          }
31  
32          public async Task<ResearchReportViewModel> 
33  GetResearchReportById(int researchReportId)
34          {
35              var report = await _researchReportRepository
36  .GetResearchReportByIdAsync(researchReportId);
37              var reportViewModel = _mapper
38  .Map<ResearchReportViewModel>(report);
39              return reportViewModel;
40          }
41  
42          public async Task<ResearchReportViewModel> 
43  AddResearchReport(ResearchReportViewModel reportViewModel)
44          {
45              var report = _mapper.Map<ResearchReport>(
46  reportViewModel);
47              var addedReport = await _researchReportRepository
48  .AddResearchReportAsync(report);
49              var addedReportViewModel = _mapper
50  .Map<ResearchReportViewModel>(addedReport);
51              return addedReportViewModel;
52          }
53  
54          public async Task<ResearchReportViewModel> 
55  UpdateResearchReport(ResearchReportViewModel reportViewModel)
56          {
57              var report = _mapper.Map<ResearchReport>(
58  reportViewModel);
59              var updatedReport = await _researchReportRepository
60  .UpdateResearchReportAsync(report);
61              var updatedReportViewModel = _mapper
62  .Map<ResearchReportViewModel>(updatedReport);
63              return updatedReportViewModel;
64          }
65  
66          public async Task DeleteResearchReport(
67  int researchReportId)
68          {
69              await _researchReportRepository
70  .DeleteResearchReportAsync(researchReportId);
71          }
72      }
73  }

Б.7 Код сервісу SensorDataService

1  using AquaTrack.Models;
2  using AquaTrack.Repositories.Interfaces;
3  using AquaTrack.Services.Interfaces;
4  using AquaTrack.ViewModels;
5  using AutoMapper;
6  
7  namespace AquaTrack.Services
8  {
9      public class SensorDataService : ISensorDataService
10      {
11          private readonly ISensorDataRepository 
12  _sensorDataRepository;
13          private readonly IMapper _mapper;
14  
15          public SensorDataService(ISensorDataRepository 
16  sensorDataRepository, IMapper mapper)
17          {
18              _sensorDataRepository = sensorDataRepository;
19              _mapper = mapper;
20          }
21  
22          public async Task<List<SensorDataViewModel>> 
23  GetAllSensorData()
24          {
25              var sensorData = await _sensorDataRepository
26  .GetAllSensorDataAsync();
27              var sensorDataViewModels = _mapper
28  .Map<List<SensorDataViewModel>>(sensorData);
29              return sensorDataViewModels;
30          }
31  
32          public async Task<SensorDataViewModel> 
33  GetSensorDataById(int sensorDataId)
34          {
35              var sensorData = await _sensorDataRepository
36  .GetSensorDataByIdAsync(sensorDataId);
37              var sensorDataViewModel = _mapper
38  .Map<SensorDataViewModel>(sensorData);
39              return sensorDataViewModel;
40          }
41  
42          public async Task<SensorDataViewModel> 
43  AddSensorData(SensorDataViewModel sensorDataViewModel)
44          {
45              var sensorData = _mapper
46  .Map<SensorData>(sensorDataViewModel);
47              var addedSensorData = await _sensorDataRepository
48  .AddSensorDataAsync(sensorData);
49              var addedSensorDataViewModel = _mapper
50  .Map<SensorDataViewModel>(addedSensorData);
51              return addedSensorDataViewModel;
52          }
53  
54          public async Task<SensorDataViewModel> 
55  UpdateSensorData(
56  SensorDataUpdateViewModel sensorDataUpdateViewModel)
57          {
58              var sensorData = _mapper.Map<SensorData>(
59  sensorDataUpdateViewModel);
60              var updatedSensorData = await _sensorDataRepository
61  .UpdateSensorDataAsync(sensorData);
62              var updatedSensorDataViewModel = _mapper
63  .Map<SensorDataViewModel>(updatedSensorData);
64              return updatedSensorDataViewModel;
65          }
66  
67          public async Task DeleteSensorData(int sensorDataId)
68          {
69              await _sensorDataRepository.DeleteSensorDataAsync(
70  sensorDataId);
71          }
72  
73          public async Task<SensorDataViewModel> 
74  FindSensorBySensorIdentificatorAndType(
75  string sensorIdentificator, SensorType sensorType)
76          {
77              var sensorData = await _sensorDataRepository
78  .FindSensorBySensorIdentificatorAndTypeAsync(
79  sensorIdentificator, sensorType);
80              var sensorDataViewModel = _mapper
81  .Map<SensorDataViewModel>(sensorData);
82              return sensorDataViewModel;
83          }
84  
85      }
86  }

Б.8 Код сервісу api_service

1  #ifndef API_COMMUNICATION_H
2  #define API_COMMUNICATION_H
3  
4  #include <WiFi.h>
5  #include <ArduinoJson.h>
6  #include <HTTPClient.h>
7  #include "constants.h"
8  #include "sensor_service.h"
9  #include <vector>
10  #include "feeding_schedule_service.h"
11  
12  bool authenticateUser(const String& userEmail, 
13  const String& userPassword) {
14    if (WiFi.status() == WL_CONNECTED) {
15      HTTPClient http;
16  
17      http.begin(String(API_BASE_URL) + "/api/User/login");
18      http.addHeader("Content-Type", "application/json");
19  
20      String requestBody = "{"email":"" + userEmail + "",
21  "password":"" + userPassword + ""}";
22      int httpResponseCode = http.POST(requestBody);
23      String responseBody = http.getString();
24  
25      if (httpResponseCode > 0) {
26        if (httpResponseCode == HTTP_CODE_OK) {
27          String response = http.getString();
28          Serial.println("Authentication successful");
29          return true;
30        } else {
31          Serial.println("Authentication failed");
32          return false;
33        }
34      } else {
35        Serial.println("Error on authentication");
36        return false;
37      }
38      http.end();
39    }
40  }
41  
42  int getSensorByIdentificator(const String& sensorIdentificator, 
43  int sensorType) {
44    if (WiFi.status() == WL_CONNECTED) {
45      HTTPClient http;
46      String url = String(API_BASE_URL) + "/api/SensorData/find";
47      url += "?sensorIdentificator=" + sensorIdentificator;
48      url += "&sensorType=" + String(sensorType);
49  
50      http.begin(url);
51      http.addHeader("Content-Type", "application/json");
52  
53      int httpResponseCode = http.GET(); 
54  
55      if (httpResponseCode > 0) {
56        if (httpResponseCode == HTTP_CODE_OK) {
57          String response = http.getString();
58          Serial.println("Sensor data retrieved successfully");
59  
60          DynamicJsonDocument jsonResponse(1024);
61          DeserializationError error = 
62  deserializeJson(jsonResponse, response);
63  
64          if (error) {
65            Serial.println("Failed to parse JSON");
66            return -1;
67          }
68  
69          int sensorDataId = jsonResponse["sensorDataId"];
70          Serial.print("Retrieved Sensor Data ID: ");
71          Serial.println(sensorDataId);
72          return sensorDataId;
73        } else {
74          Serial.println("Failed to get sensor data");
75          return -1;
76        }
77      } else {
78        Serial.println("Error on GET request");
79        return -1;
80      }
81      http.end();
82    }
83  }
84  
85  DynamicJsonDocument getAquariumByType(String aquariumType) {
86    DynamicJsonDocument jsonResponse(1024);
87  
88    if (WiFi.status() == WL_CONNECTED) {
89      HTTPClient http;
90      String url = String(API_BASE_URL) + "/api/Aquarium/find";
91      url += "?aquariumType=" + String(aquariumType);
92  
93      http.begin(url);
94      http.addHeader("Content-Type", "application/json");
95  
96      int httpResponseCode = http.GET();
97  
98      if (httpResponseCode > 0) {
99        if (httpResponseCode == HTTP_CODE_OK) {
100          String response = http.getString();
101          Serial.println("Aquarium data retrieved successfully");
102  
103          DeserializationError error = 
104  deserializeJson(jsonResponse, response);
105  
106          if (error) {
107            Serial.println("Failed to parse JSON");
108            jsonResponse.clear();
109          } else {
110            Serial.println("Aquarium data parsed successfully");
111          }
112        } else {
113          Serial.println("Failed to get aquarium data");
114          jsonResponse.clear();
115        }
116      } else {
117        Serial.println("Error on GET request");
118        jsonResponse.clear();
119      }
120      http.end();
121    } else {
122      Serial.println("WiFi not connected");
123      jsonResponse.clear();
124    }
125  
126    return jsonResponse;
127  }
128  
129  bool updateSensorData(const SensorData& sensor) {
130    if (WiFi.status() == WL_CONNECTED) {
131      HTTPClient http;
132      String url = String(API_BASE_URL) + 
133  "/api/SensorData/" + String(sensor.sensorDataId);
134      http.begin(url);
135      http.addHeader("Content-Type", "application/json");
136  
137      DynamicJsonDocument jsonBody(1024);
138      jsonBody["sensorDataId"] = sensor.sensorDataId;
139      jsonBody["sensorValue"] = sensor.sensorValue;
140      jsonBody["timestamp"] = sensor.timestamp.c_str();
141      jsonBody["sensorStatus"] = sensor.sensorStatus.c_str();
142  
143      String requestBody;
144      serializeJson(jsonBody, requestBody);
145  
146      int httpResponseCode = http.PUT(requestBody);
147  
148      Serial.println("Request body: " + requestBody);
149      
150      if (httpResponseCode > 0) {
151        if (httpResponseCode == HTTP_CODE_OK) {
152          Serial.println("Sensor data updated successfully");
153          return true;
154        } else {
155          Serial.println("Failed to update sensor data. 
156  Response code: " + String(httpResponseCode));
157          return false;
158        }
159      } else {
160        Serial.println("Error on HTTP request");
161        return false;
162      }
163      http.end();
164    }
165  }
166  
167  std::vector<FeedingSchedule> 
168  getFeedingSchedulesForAquairum(int aquariumId) {
169    std::vector<FeedingSchedule> feedingSchedules;
170  
171    if (WiFi.status() == WL_CONNECTED) {
172      HTTPClient http;
173      String url = String(API_BASE_URL) + 
174  "/api/FeedingSchedule/aquarium/";
175      url += String(aquariumId);
176      Serial.println(String(aquariumId));
177      
178      http.begin(url);
179      http.addHeader("Content-Type", "application/json");
180  
181      int httpResponseCode = http.GET(); 
182  
183      if (httpResponseCode > 0) {
184        if (httpResponseCode == HTTP_CODE_OK) {
185          String response = http.getString();
186          Serial.println("Feeding schedules
187   retrieved successfully");
188          Serial.print("Response body: ");
189          Serial.println(response);
190  
191          DynamicJsonDocument jsonResponse(2048); 
192          DeserializationError error = 
193  deserializeJson(jsonResponse, response);
194  
195          if (error) {
196            Serial.println("Failed to parse JSON");
197          } else {
198            JsonArray schedulesArray = 
199  jsonResponse.as<JsonArray>();
200            for (JsonObject schedule : schedulesArray) {
201              FeedingSchedule feedingSchedule;
202              feedingSchedule.feedingScheduleId = 
203  schedule["feedingScheduleId"];
204              feedingSchedule.aquariumId = schedule["aquariumId"];
205              feedingSchedule.feedTime = schedule["feedTime"];
206              feedingSchedule.feedAmount = 
207  schedule["feedAmount"] | 0.0; // Handle nullable value
208              feedingSchedule.feedType = 
209  schedule["feedType"].as<String>();
210              feedingSchedule.repeatInterval = 
211  schedule["repeatInterval"] | 0.0; // Handle nullable value
212              feedingSchedule.active = schedule["active"];
213              feedingSchedules.push_back(feedingSchedule);
214            }
215            Serial.println("Feeding schedules 
216  parsed successfully");
217          }
218        } else {
219          Serial.print("Failed to get feeding schedules, 
220  HTTP response code: ");
221          Serial.println(httpResponseCode);
222          String response = http.getString();
223          Serial.print("Response body: ");
224          Serial.println(response);
225        }
226      } else {
227        Serial.println("Error on GET request");
228      }
229      http.end();
230    } else {
231      Serial.println("WiFi not connected");
232    }
233  
234    return feedingSchedules; 
235  }
236  
237  #endif // API_COMMUNICATION_H

Б.9 Код оновлення інформації з сенсорів на сервері

1  /* Update sensor data on server */
2    if (WiFi.status() == WL_CONNECTED) {
3      String userEmail = "kvolnykov@gmail.com";
4      String userPassword = "user123";
5      bool authSuccess = authenticateUser(userEmail, 
6  userPassword);
7  
8      if (authSuccess) {
9        Serial.println("User logged in successfully");
10  
11        int waterLevelSensorId =
12          getSensorByIdentificator(waterLevelSensor
13  .sensorIdentificator, waterLevelSensor.sensorType);
14  
15        int temperatureSensorId
16          = getSensorByIdentificator(temperatureSensor
17  .sensorIdentificator, temperatureSensor.sensorType);
18  
19        int aciditySensorId
20          = getSensorByIdentificator(aciditySensor
21  .sensorIdentificator, aciditySensor.sensorType);
22  
23        int lightningSensorId
24          = getSensorByIdentificator(lightningSensor
25  .sensorIdentificator, lightningSensor.sensorType);
26          
27        int videoSensorId
28          = getSensorByIdentificator(videoSensor
29  .sensorIdentificator, videoSensor.sensorType);
30  
31        int movementSensorId
32          = getSensorByIdentificator(movementSensor
33  .sensorIdentificator, movementSensor.sensorType);
34  
35        /* Retrieve aquarium data */
36        DynamicJsonDocument aquariumData = 
37  getAquariumByType("SharkAquarium");
38  
39        if (!aquariumData.isNull()) {
40          float normalTemperature = aquariumData["temperature"];
41          int normalWaterLevel = aquariumData["waterLevel"];
42          int aquariumId = aquariumData["aquariumId"];
43  
44          std::vector<FeedingSchedule> feedingSchedules = 
45  getFeedingSchedulesForAquairum(aquariumId);
46          Serial.println(String(feedingSchedules.size()));
47          for (const auto& schedule : feedingSchedules) {
48            if (schedule.active) {
49              Serial.println("Schedule Activated: ");
50              Serial.print("Feeding Schedule ID: ");
51              Serial.println(schedule.feedingScheduleId);
52              Serial.print("Aquarium ID: ");
53              Serial.println(schedule.aquariumId);
54              Serial.print("Feed Time: ");
55              Serial.println(schedule.feedTime);
56              Serial.print("Feed Amount: ");
57              Serial.println(schedule.feedAmount);
58              Serial.print("Feed Type: ");
59              Serial.println(schedule.feedType);
60              Serial.print("Repeat Interval: ");
61              Serial.println(schedule.repeatInterval);
62              Serial.println("---------");
63              break;
64            }
65          }
66  
67          /* Calc current water level */
68          AquariumParams params = {normalTemperature, 
69  normalWaterLevel, temperatureSensor.sensorValue, 50.0, 
70  readHumidity()};
71          float currentWaterLevel = 
72  calculateCurrentWaterLevel(params, 1.0);
73          waterLevelSensor.sensorValue = currentWaterLevel;
74          Serial.println("Current Water Level: " 
75  + String(currentWaterLevel));
76  
77        } else {
78          Serial.println("Failed to retrieve aquarium data");
79        }
80  
81        /* Update water level sensor data on server */
82        if (waterLevelSensorId != -1) {
83          waterLevelSensor.sensorDataId = waterLevelSensorId;
84  
85          if (!updateSensorData(waterLevelSensor)) {
86            Serial.println("Failed to update water 
87  level sensor data");
88          }
89  
90        } else {
91          Serial.println("Failed to get water level sensor data");
92        }
93  
94        /* Update temperature sensor data on server */
95        if (temperatureSensorId != -1) {
96          temperatureSensor.sensorDataId = temperatureSensorId;
97  
98          if (!updateSensorData(temperatureSensor)) {
99            Serial.println("Failed to update 
100  temperature sensor data");
101          } 
102  
103        } else {
104          Serial.println("Failed to get 
105  temperature sensor data");
106        }
107  
108        /* Update acidity sensor data on server */
109        if (aciditySensorId != -1) {
110          aciditySensor.sensorDataId = aciditySensorId;
111  
112          if (!updateSensorData(aciditySensor)) {
113            Serial.println("Failed to update 
114  acidity sensor data");
115          } 
116  
117        } else {
118          Serial.println("Failed to get acidity sensor data");
119        }
120  
121        /* Update lightning sensor data on server */
122        if (lightningSensorId != -1) {
123          lightningSensor.sensorDataId = lightningSensorId;
124  
125          if (!updateSensorData(lightningSensor)) {
126            Serial.println("Failed to update 
127  lightning sensor data");
128          } 
129        } else {
130          Serial.println("Failed to get lightning sensor data");
131        }
132  
133        /* Update video sensor data on server */
134        if (videoSensorId != -1) {
135          videoSensor.sensorDataId = videoSensorId;
136  
137          if (!updateSensorData(videoSensor)) {
138            Serial.println("Failed to update video sensor data");
139          }
140  
141        } else {
142          Serial.println("Failed to get video sensor data");
143        }
144  
145        /* Update movement sensor data on server */
146        if (movementSensorId != -1) {
147          movementSensor.sensorDataId = movementSensorId;
148  
149          if (!updateSensorData(movementSensor)) {
150            Serial.println("Failed to update 
151  movement sensor data");
152          }
153        } else {
154          Serial.println("Failed to get movement sensor data");
155        }
156      }
157  
158      delay(FREQUENCY);

Б.10 Код розрахунку рівня води в акваріумі

1  /* k - Empirical constant, determined through observation */
2  float calculateCurrentWaterLevel(AquariumParams params, float k) {
3  
4      // Calculate the change in evaporation rate
5      float deltaE = k * ((params.T_current - params.T_normal) 
6  / params.T_normal - 
7                          (params.H_current - params.H_normal) 
8  / params.H_normal);
9  
10      // Calculate the water loss
11      float deltaL = deltaE;
12  
13      // Calculate the current water level
14      float L_current = params.L_normal - deltaL;
15  
16      return L_current;

Б.11 Код компоненту AdminAquarium

1  import React, { useState, useEffect } from 'react';
2  import { Typography, Button, Divider, List, ListItem, 
3  ListItemText, ListItemSecondaryAction } from '@mui/material';
4  import { useTranslation } from 'react-i18next';
5  import { getAquariumsForUser, deleteAquariumForUser } 
6  from '../../../api/aquariums/aquariums';
7  import { Link, useNavigate, useParams, useSearchParams } 
8  from 'react-router-dom';
9  import LanguageSwitcher 
10  from '../../LanguageSwitcher/LanguageSwitcher';
11  import NavigationBar 
12  from '../../user_components/NavigationBar/NavigationBar';
13  
14  const AdminAquarium = ({ selectedUserId }) => {
15    const { t } = useTranslation();
16    const [aquariums, setAquariums] = useState([]);
17    const navigate = useNavigate();
18    const { userId } = useParams();
19  
20    useEffect(() => {
21      if (userId) {
22        const fetchAquariums = async () => {
23          try {
24            const data = await getAquariumsForUser(userId);
25            console.log(data);
26            setAquariums(data);
27          } catch (error) {
28            console.error(error.message);
29          }
30        };
31        fetchAquariums();
32      }
33    }, [userId]);
34  
35    const handleDelete = async (id) => {
36      try {
37        await deleteAquariumForUser(id, userId);
38        setAquariums(aquariums.filter(aquarium => 
39  aquarium.id !== id));
40      } catch (error) {
41        console.error(error.message);
42      }
43    };
44  
45    return (
46      <div>
47        <NavigationBar title = 
48  {t('aquarium.aquariumAdministration')}></NavigationBar>
49        <Divider />
50        <Button
51          variant="contained"
52          color="primary"
53          component={Link}
54          to={`/admin/aquarium/add/${userId}`}
55        >
56          {t('aquarium.addAquarium')}
57        </Button>
58        <Divider />
59        <List sx={{maxWidth: "600px", marginInline: 
60  "auto", padding: "20px"}}>
61          {aquariums.map((aquarium) => (
62            <ListItem key={aquarium.aquariumId}>
63              <ListItemText
64                primary={aquarium.name}
65                secondary={`${t('aquarium.type')}: 
66  ${aquarium.aquariumType}`}
67              />
68              <ListItemSecondaryAction>
69                <Button
70                  variant="contained"
71                  color="primary"
72                  component={Link}
73                  to={`/admin/aquarium/${userId}/update/
74  ${aquarium.aquariumId}`}
75                >
76                  {t('aquarium.update')}
77                </Button>
78                <Button
79                  variant="contained"
80                  color="secondary"
81                  onClick={() => handleDelete(
82  aquarium.aquariumId)}
83                >
84                  {t('aquarium.delete')}
85                </Button>
86                <Button
87                  variant="contained"
88                  color="warning"
89                  component={Link}
90                  to={`/general/aquarium/view/${aquarium
91  .aquariumId}`}
92                >
93                  {t('aquarium.view')}
94                </Button>
95              </ListItemSecondaryAction>
96            </ListItem>
97          ))}
98        </List>
99      </div>
100    );
101  };
102  
103  export default AdminAquarium;

Б.12 Код компоненту UserAquiarium

1  import React, { useState, useEffect } from 'react';
2  import { Typography, Button, Divider, List, 
3  ListItem, ListItemText, ListItemSecondaryAction } 
4  from '@mui/material';
5  import { useTranslation } from 'react-i18next';
6  import { getAquariumsForUser, deleteAquariumForUser } 
7  from '../../../api/aquariums/aquariums';
8  import { Link, useNavigate, useParams, useSearchParams } 
9  from 'react-router-dom';
10  import NavigationBar 
11  from '../../user_components/NavigationBar/NavigationBar';
12  
13  const UserAquarium = ({ selectedUserId }) => {
14    const { t } = useTranslation();
15    const [aquariums, setAquariums] = useState([]);
16    const navigate = useNavigate();
17    const userId = localStorage.getItem("userId");
18  
19    useEffect(() => {
20      if (userId) {
21        const fetchAquariums = async () => {
22          try {
23            const data = await getAquariumsForUser(userId);
24            setAquariums(data);
25          } catch (error) {
26            console.error(error.message);
27          }
28        };
29        fetchAquariums();
30      }
31    }, [userId]);
32  
33    const handleDelete = async (id) => {
34      try {
35        await deleteAquariumForUser(id, userId);
36        setAquariums(aquariums.filter(aquarium => 
37  aquarium.id !== id));
38      } catch (error) {
39        console.error(error.message);
40      }
41    };
42  
43    return (
44      <div>
45        <NavigationBar title = 
46  {t('aquarium.aquariumAdministration')}></NavigationBar>
47        <Divider />
48        
49        <List sx={{maxWidth: "600px", marginInline: 
50  "auto", padding: "20px"}}>
51          {aquariums.map((aquarium) => (
52            <ListItem key={aquarium.aquariumId}>
53              <ListItemText
54                secondary={`${t('aquarium.type')}: 
55  ${aquarium.aquariumType}`}
56              />
57              <ListItemSecondaryAction>
58                <Button
59                  variant="contained"
60                  color="warning"
61                  component={Link}
62                  to={`/general/aquarium/view/${aquarium
63  .aquariumId}`}
64                >
65                  {t('aquarium.view')}
66                </Button>
67                <Button
68                  variant="contained"
69                  color="info"
70                  component={Link}
71                  to={`/user/inhabitant/${aquarium.aquariumId}`}
72                >
73                  {t('aquarium.inhabitants')}
74                </Button>
75              </ListItemSecondaryAction>
76            </ListItem>
77          ))}
78        </List>
79      </div>
80    );
81  };
82  
83  export default UserAquarium;

Б.13 Код компоненту Inhabitant

1  import React, { useState, useEffect } from 'react';
2  import { Typography, Button, Divider, List, ListItem, 
3  ListItemText, ListItemSecondaryAction, TextField, 
4  Dialog, DialogActions, DialogContent, 
5  DialogContentText, DialogTitle } from '@mui/material';
6  import { useTranslation } from 'react-i18next';
7  import { Link, useParams } from 'react-router-dom';
8  import { deleteInhabitantForCurrentUser, 
9  getInhabitantsForAquarium } 
10  from '../../../api/inhabitants/inhabitants';
11  import NavigationBar 
12  from '../../user_components/NavigationBar/NavigationBar';
13  
14  const Inhabitant = () => {
15    const { t } = useTranslation();
16    const { aquariumId } = useParams();
17    const [inhabitants, setInhabitants] = useState([]);
18  
19    useEffect(() => {
20      const fetchInhabitants = async () => {
21        try {
22          const data = await 
23  getInhabitantsForAquarium(aquariumId);
24          setInhabitants(data);
25        } catch (error) {
26          console.error(error.message);
27        }
28      };
29      fetchInhabitants();
30    }, [aquariumId]);
31  
32    const handleDelete = async (id) => {
33      try {
34        await deleteInhabitantForCurrentUser(id);
35        setInhabitants(inhabitants.filter(inhabitant => 
36  inhabitant.inhabitantId !== id));
37      } catch (error) {
38        console.error(error.message);
39      }
40    };
41  
42    return (
43      <div>
44        <NavigationBar title={t('inhabitant.inhabitants')} />
45        <Divider />
46  
47        <Button
48          variant="contained"
49          color="primary"
50          component={Link}
51          to={`/user/inhabitant/add/${aquariumId}`}
52        >
53          {t('inhabitant.add')}
54        </Button>
55  
56        <Divider />
57        <List sx={{maxWidth: "600px", marginInline: 
58  "auto", padding: "20px"}}>
59          {inhabitants.map((inhabitant) => (
60            <ListItem key={inhabitant.inhabitantId}>
61              <ListItemText
62                primary={inhabitant.name}
63                secondary={`${t('inhabitant.species')}: 
64  ${inhabitant.species}`}
65              />
66              <ListItemSecondaryAction>
67                <Button
68                  variant="contained"
69                  color="primary"
70                  component={Link}
71                  to={`/user/inhabitant/${aquariumId}/update/${
72  inhabitant.inhabitantId}`}
73                >
74                  {t('inhabitant.update')}
75                </Button>
76                <Button
77                  variant="contained"
78                  color="secondary"
79                  onClick={() => handleDelete(inhabitant
80  .inhabitantId)}
81                  sx={{marginInline: "4px"}}
82                >
83                  {t('inhabitant.delete')}
84                </Button>
85                <Button
86                  variant="contained"
87                  color="warning"
88                  component={Link}
89                  to={`/user/inhabitant/view/${inhabitant
90  .inhabitantId}`}
91                >
92                  {t('inhabitant.view')}
93                </Button>
94              </ListItemSecondaryAction>
95            </ListItem>
96          ))}
97        </List>
98      </div>
99    );
100  };
101  
102  export default Inhabitant;

Б.14 Код компоненту ResearchReport

1  import React, { useState, useEffect } from 'react';
2  import { TextField, List, ListItem, ListItemText, 
3  Divider, Button, ListItemSecondaryAction } 
4  from '@mui/material';
5  import { useTranslation } from 'react-i18next';
6  import { deleteResearchReport, getAllResearchReports } 
7  from '../../../api/researchReports/researchReports';
8  import { getAquariumById } 
9  from '../../../api/aquariums/aquariums';
10  import NavigationBar 
11  from '../../user_components/NavigationBar/NavigationBar';
12  import { Link } from 'react-router-dom';
13  
14  const ResearchReport = () => {
15    const { t } = useTranslation();
16    const [researchReports, setResearchReports] = useState([]);
17    const [aquariums, setAquariums] = useState({});
18    const [filter, setFilter] = useState('');
19  
20    useEffect(() => {
21      const fetchReports = async () => {
22        try {
23          const reports = await getAllResearchReports();
24          setResearchReports(reports);
25          
26          const aquariumPromises = reports.map(report => 
27  getAquariumById(report.aquariumId));
28          const aquariumResults = await Promise
29  .all(aquariumPromises);
30  
31          const aquariumMap = {};
32          aquariumResults.forEach(aquarium => {
33            aquariumMap[aquarium.aquariumId] = 
34  aquarium.aquariumType;
35          });
36          setAquariums(aquariumMap);
37        } catch (error) {
38          console.error('Error fetching data:', error);
39        }
40      };
41      fetchReports();
42    }, []);
43  
44    const handleDelete = async (id) => {
45      try {
46        await deleteResearchReport(id);
47        setResearchReports(researchReports.filter(
48  researchReports => researchReports.researchReportId !== id));
49      } catch (error) {
50        console.error(error.message);
51      }
52    };
53  
54    const filteredReports = researchReports.filter(report => {
55      const aquariumType = aquariums[report.aquariumId];
56      return filter ? aquariumType && aquariumType
57  .toLowerCase().includes(filter.toLowerCase()) : true;
58    });
59  
60    return (
61      <div>
62        <NavigationBar title={t('researchReport.researchReports')} />
63        
64        <Divider />
65        <Button
66          sx={{marginInline: "4px"}}
67          variant="contained"
68          color="primary"
69          component={Link}
70          to={`/user/research-report/add`}
71        >
72          {t('researchReport.add')}
73        </Button>
74  
75        <TextField
76          label={t('researchReport.filterByAquariumType')}
77          fullWidth
78          margin="normal"
79          value={filter}
80          onChange={(e) => setFilter(e.target.value)}
81        />
82        <List sx={{maxWidth: "600px", marginInline: 
83  "auto", padding: "20px"}}>
84          {filteredReports.map(report => (
85            <ListItem key={report.researchReportId}>
86              <ListItemText
87                primary={`Research Report ID: ${report
88  .researchReportId}`}
89                secondary={`Aquarium Type: ${aquariums[
90  report.aquariumId] || t('loading')}`}
91              />
92              <ListItemSecondaryAction>
93                <Button
94                  variant="contained"
95                  color="secondary"
96                  onClick={() => handleDelete(
97  report.researchReportId)}
98                  sx={{marginInline: "4px"}}
99                >
100                  {t('researchReport.delete')}
101                </Button>
102              </ListItemSecondaryAction>
103            </ListItem>
104          ))}
105        </List>
106      </div>
107    );
108  };
109  
110  export default ResearchReport;

Б.15 Код компоненту AnalysisReport

1  import React, { useState, useEffect } from 'react';
2  import { TextField, List, ListItem, ListItemText, 
3  Divider, Button, ListItemSecondaryAction } from '@mui/material';
4  import { useTranslation } from 'react-i18next';
5  import { deleteAnalysisReport, getAllAnalysisReports } 
6  from '../../../api/analysisReports/analysisReports';
7  import { getAllResearchReports, getResearchReportById } 
8  from '../../../api/researchReports/researchReports';
9  import { getAquariumById } 
10  from '../../../api/aquariums/aquariums';
11  import NavigationBar 
12  from '../../user_components/NavigationBar/NavigationBar';
13  import { Link, useNavigate } from 'react-router-dom';
14  
15  const AnalysisReport = () => {
16    const { t } = useTranslation();
17    const [analysisReports, setAnalysisReports] = useState([]);
18    const [researchReports, setResearchReports] = useState([]);
19    const [aquariums, setAquariums] = useState({});
20    const [filter, setFilter] = useState('');
21    const navigate = useNavigate();
22  
23    useEffect(() => {
24      const fetchReports = async () => {
25        try {
26          const analysisReports = await getAllAnalysisReports();
27          setAnalysisReports(analysisReports);
28          
29          const researchReportPromises = 
30  analysisReports.map(report => getResearchReportById(
31  report.researchReportId));
32          const researchReports = await Promise.all(
33  researchReportPromises);
34          setResearchReports(researchReports);
35  
36          const aquariumPromises = researchReports.map(
37  report => getAquariumById(report.aquariumId));
38          const aquariumResults = await Promise.all(
39  aquariumPromises);
40  
41          const aquariumMap = {};
42          aquariumResults.forEach(aquarium => {
43            aquariumMap[aquarium.aquariumId] = 
44  aquarium.aquariumType;
45          });
46          setAquariums(aquariumMap);
47        } catch (error) {
48          console.error('Error fetching data:', error);
49        }
50      };
51      fetchReports();
52    }, []);
53  
54    const handleDelete = async (id) => {
55      try {
56        await deleteAnalysisReport(id);
57        setAnalysisReports(analysisReports.filter(
58  report => report.analysisReportId !== id));
59      } catch (error) {
60        console.error(error.message);
61      }
62    };
63  
64    const handleView = (id) => {
65      navigate(`/user/analysis-report/view/${id}`);
66    };
67  
68    const filteredReports = analysisReports.filter(report => {
69      const researchReport = researchReports.find(
70  r => r.researchReportId === report.researchReportId);
71      const aquariumType = researchReport && aquariums[
72  researchReport.aquariumId];
73      return filter ? aquariumType && aquariumType
74  .toLowerCase().includes(filter.toLowerCase()) : true;
75    });
76  
77    return (
78      <div>
79        <NavigationBar title={t('analysisReport.analysisReports')} />
80        
81        <Divider />
82        <Button
83          sx={{ marginInline: "4px" }}
84          variant="contained"
85          color="primary"
86          component={Link}
87          to={`/user/analysis-report/add`}
88        >
89          {t('analysisReport.add')}
90        </Button>
91  
92        <TextField
93          label={t('analysisReport.filterByAquariumType')}
94          fullWidth
95          margin="normal"
96          value={filter}
97          onChange={(e) => setFilter(e.target.value)}
98        />
99        <List sx={{ maxWidth: "600px", marginInline: 
100  "auto", padding: "20px" }}>
101          {filteredReports.map(report => {
102            const researchReport = researchReports.find(
103  r => r.researchReportId === report.researchReportId);
104            const aquariumType = researchReport && 
105  aquariums[researchReport.aquariumId];
106            return (
107              <ListItem key={report.analysisReportId}>
108                <ListItemText
109                  primary={`Analysis Report ID: ${
110  report.analysisReportId}`}
111                  secondary={`Aquarium Type: ${
112  aquariumType || t('loading')}`}
113                />
114                <ListItemSecondaryAction>
115                  <Button
116                    variant="contained"
117                    color="secondary"
118                    onClick={() => handleDelete(
119  report.analysisReportId)}
120                    sx={{ marginInline: "4px" }}
121                  >
122                    {t('analysisReport.delete')}
123                  </Button>
124                  <Button
125                    variant="contained"
126                    color="primary"
127                    onClick={() => handleView(
128  report.analysisReportId)}
129                    sx={{ marginInline: "4px" }}
130                  >
131                    {t('analysisReport.view')}
132                  </Button>
133                </ListItemSecondaryAction>
134              </ListItem>
135            );
136          })}
137        </List>
138      </div>
139    );
140  };
141  
142  export default AnalysisReport;

Б.16 Код сервісу AquariumApi

1  package com.example.aquatrackmobile.models.Aquarium
2  
3  import io.ktor.client.*
4  import io.ktor.client.call.*
5  import io.ktor.client.request.*
6  import io.ktor.client.statement.*
7  import io.ktor.http.*
8  import com.example.aquatrackmobile.models.Aquarium.Aquarium
9  
10  class AquariumApiException(message: String, cause: Throwable? 
11  = null) : Exception(message, cause)
12  
13  interface AquariumApi {
14      val client: HttpClient
15  
16      suspend fun getAquariumById(id: Int): Aquarium
17      suspend fun getAquariumsForUser(userId: Int): 
18  List<Aquarium>
19  
20  }
21  
22  class AquariumApiImpl(override val client: HttpClient) : 
23  AquariumApi {
24  
25      private val apiKey: String = 
26  "http://0.tcp.eu.ngrok.io:13176/api"
27  
28      override suspend fun getAquariumById(id: Int): Aquarium {
29          val response: HttpResponse = 
30  client.get("$apiKey/Aquarium/$id")
31          if (response.status.isSuccess()) {
32              return response.body()
33          } else {
34              throw AquariumApiException("
35  Failed to fetch aquarium by ID")
36          }
37      }
38  
39      override suspend fun getAquariumsForUser(userId: Int): 
40  List<Aquarium> {
41          val response: HttpResponse = 
42  client.get("$apiKey/Aquarium/user/$userId")
43          if (response.status.isSuccess()) {
44              return response.body()
45          } else {
46              throw AquariumApiException("
47  Failed to fetch aquariums for user")
48          }
49      }
50  
51  }

Б.17 Код сервісу UserApi

1  package com.example.aquatrackmobile.models.User
2  
3  import com.example.aquatrackmobile.network.HttpClientProvider
4  import io.ktor.client.*
5  import io.ktor.client.call.*
6  import io.ktor.client.request.*
7  import io.ktor.client.statement.*
8  import io.ktor.http.*
9  import kotlinx.serialization.encodeToString
10  import kotlinx.serialization.json.*
11  
12  class LoginException(message: String, cause: Throwable? = null)
13   : Exception(message, cause)
14  class RegisterException(message: String, cause: Throwable? 
15  = null) : Exception(message, cause)
16  
17  interface UserApi {
18      val client: HttpClient
19  
20      suspend fun loginUser(email: String, password: String): 
21  UserResponse
22      suspend fun getCurrentUser(): UserResponse
23      suspend fun registerUser(email: String, password: String, 
24  username: String): UserResponse
25  }
26  
27  class UserApiImpl(override val client: HttpClient = 
28  HttpClientProvider.client) : UserApi {
29  
30      private val apiKey: String = 
31  "http://0.tcp.eu.ngrok.io:13176/api"
32  
33      override suspend fun loginUser(email: String, 
34  password: String): UserResponse {
35          val requestBody = buildJsonObject {
36              put("email", email)
37              put("password", password)
38          }
39          println(requestBody)
40          try {
41              val response: HttpResponse = 
42  client.post("$apiKey/user/login") {
43                  contentType(ContentType.Application.Json)
44                  setBody(Json.encodeToString(requestBody))
45              }
46  
47              if (response.status.isSuccess()) {
48                  return response.body()
49              } else {
50                  throw LoginException("Invalid 
51  credentials or other login failure")
52              }
53          } catch (e: Exception) {
54              throw LoginException("Error 
55  during login ${e.message}", e)
56          }
57      }
58  
59      override suspend fun getCurrentUser(): UserResponse {
60          val response: HttpResponse 
61  = client.get("$apiKey/user/userinfo") {
62              headers {
63                  append(HttpHeaders.Accept, "application/json")
64              }
65          }
66          return response.body()
67      }
68  
69      override suspend fun registerUser(
70  email: String, password: String, username: String): 
71  UserResponse {
72          val requestBody = buildJsonObject {
73              put("email", email)
74              put("password", password)
75              put("username", username)
76          }
77  
78          try {
79              val response: HttpResponse = 
80  client.post("$apiKey/user/register") {
81                  contentType(ContentType.Application.Json)
82                  setBody(Json.encodeToString(requestBody))
83              }
84  
85              if (response.status.isSuccess()) {
86                  return response.body()
87              } else {
88                  throw LoginException("Registration failed")
89              }
90          } catch (e: Exception) {
91              throw LoginException("Error during registration", e)
92          }
93      }
94  }

Б.18 Код сервісу FeedingScheduleApi

1  package com.example.aquatrackmobile.models.FeedingSchedule
2  
3  import io.ktor.client.*
4  import io.ktor.client.call.*
5  import io.ktor.client.request.*
6  import io.ktor.client.statement.*
7  import io.ktor.http.*
8  import kotlinx.serialization.json.*
9  
10  class FeedingScheduleApiException(message: String, cause: 
11  Throwable? = null) : Exception(message, cause)
12  
13  interface FeedingScheduleApi {
14      val client: HttpClient
15  
16      suspend fun getFeedingSchedulesByAquariumId(id: Int): 
17  List<FeedingSchedule>
18      suspend fun getFeedingScheduleById(id: Int): 
19  FeedingSchedule
20      suspend fun addFeedingScheduleForCurrentUser(
21  feedingSchedule: FeedingSchedule): FeedingSchedule
22      suspend fun updateFeedingScheduleForCurrentUser(
23  id: Int, feedingSchedule: FeedingSchedule): FeedingSchedule
24      suspend fun deleteFeedingScheduleForCurrentUser(id: Int)
25  }
26  
27  class FeedingScheduleApiImpl(override val client: HttpClient) 
28  : FeedingScheduleApi {
29  
30      private val apiKey: String = 
31  "http://0.tcp.eu.ngrok.io:13176/api"
32  
33      override suspend fun getFeedingSchedulesByAquariumId(
34  id: Int): List<FeedingSchedule> {
35          val response: HttpResponse = 
36  client.get("$apiKey/FeedingSchedule/aquarium/$id")
37          if (response.status.isSuccess()) {
38              return response.body()
39          } else {
40              throw FeedingScheduleApiException(
41  "Failed to fetch feeding schedules by aquarium ID")
42          }
43      }
44  
45      override suspend fun getFeedingScheduleById(id: Int): 
46  FeedingSchedule {
47          val response: HttpResponse = 
48  client.get("$apiKey/FeedingSchedule/$id")
49          if (response.status.isSuccess()) {
50              return response.body()
51          } else {
52              throw FeedingScheduleApiException(
53  "Failed to fetch feeding schedule by ID")
54          }
55      }
56  
57      override suspend fun addFeedingScheduleForCurrentUser(
58  feedingSchedule: FeedingSchedule): FeedingSchedule {
59          val response: HttpResponse = 
60  client.post("$apiKey/FeedingSchedule") {
61              contentType(ContentType.Application.Json)
62              setBody(feedingSchedule)
63          }
64          if (response.status.isSuccess()) {
65              return response.body()
66          } else {
67              throw FeedingScheduleApiException(
68  "Failed to add feeding schedule for current user")
69          }
70      }
71  
72      override suspend fun updateFeedingScheduleForCurrentUser(
73  id: Int, feedingSchedule: FeedingSchedule): FeedingSchedule {
74          val response: HttpResponse = 
75  client.put("$apiKey/FeedingSchedule/$id") {
76              contentType(ContentType.Application.Json)
77              setBody(feedingSchedule)
78          }
79          if (response.status.isSuccess()) {
80              return response.body()
81          } else {
82              throw FeedingScheduleApiException(
83  "Failed to update feeding schedule for current user")
84          }
85      }
86  
87      override suspend fun deleteFeedingScheduleForCurrentUser(
88  id: Int) {
89          val response: HttpResponse = 
90  client.delete("$apiKey/FeedingSchedule/$id")
91          if (!response.status.isSuccess()) {
92              throw FeedingScheduleApiException(
93  "Failed to delete feeding schedule for current user")
94          }
95      }

Б.19 Код сервісу SensorDataApi

1  package com.example.aquatrackmobile.models.SensorData
2  
3  import io.ktor.client.*
4  import io.ktor.client.call.*
5  import io.ktor.client.request.*
6  import io.ktor.client.statement.*
7  import io.ktor.http.*
8  import kotlinx.serialization.json.*
9  
10  class SensorDataApiException(message: String, cause: 
11  Throwable? = null) : Exception(message, cause)
12  
13  interface SensorDataApi {
14      val client: HttpClient
15  
16      suspend fun getAllSensorData(): List<SensorData>
17      suspend fun getSensorDataById(id: Int): SensorData
18      suspend fun addSensorData(sensorData: SensorData): 
19  SensorData
20      suspend fun deleteSensorData(id: Int)
21  }
22  
23  class SensorDataApiImpl(override val client: HttpClient) : 
24  SensorDataApi {
25  
26      private val apiKey: String = 
27  "http://0.tcp.eu.ngrok.io:13176/api"
28  
29      override suspend fun getAllSensorData(): List<SensorData> {
30          val response: HttpResponse = 
31  client.get("$apiKey/SensorData")
32          if (response.status.isSuccess()) {
33              println(response)
34              return response.body()
35          } else {
36              throw SensorDataApiException(
37  "Failed to fetch all sensor data")
38          }
39      }
40  
41      override suspend fun getSensorDataById(id: Int): 
42  SensorData {
43          val response: HttpResponse = 
44  client.get("$apiKey/SensorData/$id")
45          if (response.status.isSuccess()) {
46              return response.body()
47          } else {
48              throw SensorDataApiException(
49  "Failed to fetch sensor data by ID")
50          }
51      }
52  
53      override suspend fun addSensorData(
54  sensorData: SensorData): SensorData {
55          val response: HttpResponse = 
56  client.post("$apiKey/SensorData") {
57              contentType(ContentType.Application.Json)
58              setBody(sensorData)
59  
60          }
61          println(sensorData)
62          println(response)
63          if (response.status.isSuccess()) {
64              return response.body()
65          } else {
66              throw SensorDataApiException(
67  "Failed to add sensor data")
68          }
69      }
70  
71      override suspend fun deleteSensorData(id: Int) {
72          val response: HttpResponse = 
73  client.delete("$apiKey/SensorData/$id")
74          if (!response.status.isSuccess()) {
75              throw SensorDataApiException(
76  "Failed to delete sensor data")
77          }
78      }
79  



ДОДАТОК В
Результат перевірки пояснювальної записки на плагіат


 
